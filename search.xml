<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[deepin安装Oracle 12c R2(详细)]]></title>
    <url>%2Fdatabase%2F14360.html</url>
    <content type="text"><![CDATA[图解在deepin系统下安装Oracle Database 12c Release 2数据库 写在前面首先明确一点，在Linux下安装Oracle数据库事实上并不是一件容易的事情（Linux大牛除外），尤其是当你使用的Linux发行版不是Red Hat或者Centos这种服务器型的发行版的时候。网上大部分的教程都是针对Red Hat、Centos以及Ubuntu的，所以当我自己决定在deepin上安装Oracle的时候，我已经准备好踩坑了，而事实也证明了安装的过程确实是一波三折，OK，废话就不说了，直接进入主题。 安装前准备下载你自己需要安装的Oracle版本，我这里选择的是Oracle Database 12c Release 2这个版本，有一点要注意的地方就是下载需要登录Oracle账户。下载地址：http://www.oracle.com/technetwork/database/enterprise-edition/downloads/index.html 下载完成后，我们需要校验一下文件是否损坏,切换到文件的下载目录，执行以下命令 12// filename 为下载的文件名cksum filename 对比Oracle官网提供的校验码，如果一致，那么说明文件没有损坏 开始安装在正式开始安装之前，请移步到Oracle官网查看数据库安装指南的相关信息，尤其是依赖部分。文档地址: https://docs.oracle.com/en/database/oracle/oracle-database/12.2/install-and-upgrade.html 解压文件切换到文件的下载目录，将文件解压 执行mv database /opt/将解压后的文件拷贝到/opt/目录下，这里你可以根据你自己的需要拷贝到其他文件夹 创建用户使用以下命令创建Oracle用户，并设置密码 123456789groupadd dbauseradd -d /opt/oracle -m -c "Oracle Database" -g dba -G sudo -s `which bash` oraclepasswd oracle## -d：参数是指定用户主目录## -m：自动建立用户的登入目录## -c：用户描述## -g：指定用户所属的组## -G：指定用户所属的附加组## -s：指定用户登入后所使用的shell 修改参数编辑/etc/security/limits.conf文件，在文件的最后添加如下的配置（你可以根据你自己的需要进行配置） 123456oracle soft nofile 1024oracle hard nofile 65536oracle soft nproc 2047oracle hard nproc 16384oracle soft stack 10240oracle hard stack 32768 编辑/etc/sysctl.conf文件，在文件的最后添加如下的配置（你可以根据你自己的需要进行调整） 1234567891011fs.file-max=6815744kernel.sem=250 32000 100 128kernel.shmmni=4096kernel.shmall=1073741824kernel.shmmax=4398046511104net.core.rmem_default=262144net.core.rmem_max=4194304net.core.wmem_default=262144net.core.wmem_max=1048576fs.aio-max-nr=1048576net.ipv4.ip_local_port_range=9000 65500 安装依赖依赖部分请务必安装完整，否则后面的安装会出现各种各样的问题，关于依赖请参考上面Oracle官网的安装文档，注意:官网提供的依赖是 Red Hat 以及 Oracle Linux 的，仅供参考。在 deepin 中安装如下依赖（此部分依赖并不一定完整，需要根据你自己的电脑来调整） 1apt-get install libaio-dev sysstat unixodbc-dev libelf-dev unzip g++ zlib1g-dev ksh libstdc++5 binutil 建立软连接在终端中执行如下命令建立软连接 123456789sudo mkdir /usr/lib64sudo ln -s /usr/bin/awk /bin/awksudo ln -s /usr/bin/basename /bin/basenamesudo ln -s /usr/bin/rpm /bin/rpmsudo ln -s /etc /etc/rc.dsudo ln -s /usr/lib/x86_64-linux-gnu/libpthread_nonshared.a /usr/lib64/sudo ln -s /usr/lib/x86_64-linux-gnu/libc_nonshared.a /usr/lib64/sudo ln -s /lib/x86_64-linux-gnu/libgcc_s.so.1 /libsudo ln -s /usr/lib/x86_64-linux-gnu/libstdc++.so.6 /usr/lib64/ 运行安装程序在终端中切换到Oracle用户，进入/opt/database目录下，为了避免安装界面出现乱码，执行export LANG=en_us，之后执行./runInstaller 12345su oraclecd /opt/databaseexport LANG=en_usexport NLS_LANG=AMERICAN_AMERICA.UTF8export LC_ALL=C 在执行./runInstaller的时候，提示无法使用命令/usr/bin/xdpyinfo自动检查显示器颜色 在终端中执行xdpyinfo命令查看显示器的颜色信息，发现没问题，所以问题不在这儿，通过百度发现，需要使用之前创建的oracle用户登录系统才能调用安装程序，所以切换oracle用户登录系统，注意不是在终端切换用户 图形化安装使用oracle用户登录系统后，同样切换到/opt/database目录下，同样为了避免出现乱码，执行以下命令 123export LANG=en_usexport NLS_LANG=AMERICAN_AMERICA.UTF8export LC_ALL=C 之后执行./runInstaller，成功调出安装界面 这里提示说Oracle不支持当前的操作系统，问你是否继续，我们选择yes继续 将接受安全更新和技术支持前的钩去掉 在弹出的警告框中选择yes，继续安装 选择安装选项，选择创建并配置数据库，然后next 接下来选择系统类型，这里选择服务器类型，然后next 接下来选择数据库的安装选项，这里选择单实例数据库，然后next 接下来选择安装类型，这里选择高级安装，然后next 接下来选择数据库的版本，这里选择安装企业版，然后next 接下来指定安装目录，这里选择默认的即可，然后next 接下来创建inventory目录，此目录用于存放数据库的一些相关信息，这里选择默认的即可，然后next 接下来选择配置类型，这里选择一般用途/事务处理，然后next 接下来指定数据的标识符，这里选择默认即可，然后next 接下来指定配置选项，内存方面默认即可，但是字符集要注意选择UTF-8 为了方便学习sql语句，将example schemas选项下的创建具有实例方案的数据库前的钩打上 接下来指定数据库的存储选项，这里也是选择默认即可，然后next 接下来指定管理选项，这里直接跳过，选择next 接下来指定数据恢复选项，这里也直接跳过，选择next 接下来指定数据库密码，为了方面，这里我将密码统一设置为oracleadmin，这里的密码是不符合强度要求的，真实的生产环境是不可能设置，这里仅仅是为了方便个人学习使用而设置成这样的。 设置完密码后，会提示密码不符合oracle的标准，问你是否继续，选择yes继续即可 接下来配置授权的操作系统组，这里全部选择dba，然后next 接下来检查安装的配置信息，检查无误后，选择install开始安装 开始进行安装。。。 在安装到65%的时候报了一个错误Error in invoking target &#39;links proc gen_pcscfg procob&#39; of makefile... 参考文章1: http://www.techienote.com/install-oracle-12c-on-ubuntu/参考文章2: https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=43149 出现这个问题，首先检查依赖有没有问题，如果依赖没有问题，再去尝试其他的解决办法，此处省略一万个字…网上有许多类似的问题的解决办法，这里我就不一一讲了，这里直接讲我是如何解决的，切换到root用户，执行以下命令，注意此处针对的是deepin 15.2版本以上的系统。 123456apt-get install gcc-4.8 g++-4.8cd /usr/binmv gcc gcc.scriptmv g++ g++.scriptln -s gcc-4.8 gcc ln -s g++-4.8 g++ 之后选择Retry重新尝试，在弹窗中选择OK继续安装 在安装到79%的时候，提示The installer has detected that current home is not registered in the central inventory on this system，问你是否继续，这里选择yes继续安装 然后在安装到92%的时候又报了个错误:[INS-20802] Oracle Net Configuration Assistant failed，百度搜了一堆办法，但是最后我直接选择Ok，之后点击Retry重试，没问题，安装正常 胜利在望。。。 bingo…安装完成，点击close关闭安装界面 安装完成后，将gcc,g++的版本改回默认，切换到/usr/bin/目录下，执行以下命令: 12mv g++.script g++mv gcc.script gcc 配置环境变量修改~/.bashrc文件，添加如下内容，注意这里要根据你自己的安装位置进行调整 1234export ORACLE_BASE=/opt/oracle/app/oracle export ORACLE_HOME=/opt/oracle/app/oracle/product/12.2.0/dbhome_1export PATH=$PATH:$ORACLE_HOME/binexport ORACLE_SID=orcl 测试安装在保存完环境变量后，新开一个终端窗口，输入以下命令连接数据库: 1sqlplus &quot;/as sysdba&quot; oracle用户下，连接数据库没有问题，接下来使用原来的账户登录系统，再次执行以下命令连接数据库: 1sqlplus &quot;/as sysdba&quot; bingo…测试没问题，至此，Oracle Database 12c Release 2已经在deepin上安装成功了。 总结总的来说，这一次安装Oracle数据库几乎花费了我一整天的时间，是24小时的那种，因为学校晚上12点断网，所以在安装的过程中遇到问题（在安装到65%出错的时候恰好已经过了12点）的时候没法上网查找，不得不留到第二天继续安装，中间我都没关电脑，再加上写这篇文章，估计都满24小时了。不过最终能够安装成功也算有所收收获，毕竟在安装的过程中自己也学到了不少东西，包括linux上的各种配置以及命令的使用。OK，文章到此就结束了，撒花~~~~]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>deepin</tag>
        <tag>linux</tag>
        <tag>oracle 12c R2</tag>
        <tag>安装图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多表查询与子查询的性能比较]]></title>
    <url>%2Fdatabase%2F45385.html</url>
    <content type="text"><![CDATA[使用MySQL官方提供的测试数据库来测试多表关联查询与子查询的性能到底谁更胜一筹 写在前面在程序员的世界里，从来都不缺争论，从世界上最好的语言到世界上最好的IDE再到世界上最好的编辑器，这场没有硝烟的战争从未停止过，当然我自己从来都不会参与其中，也许我是个假程序员，在我看来，最好的东西，从来都不存在，没有最好只有最适合。咳咳~~~好像都点跑题了，是这样，最近跟朋友吃饭的时候，聊到了关于MySQL数据库的多表查询与子查询的性能问题，我的朋友认为多表查询的性能要优于子查询的性能，而我自己认为子查询的性能要优于多表查询，大家都各执一词，谁也没能说服谁，与其这样争论不休、倒不如让数据说话，使用模拟数据进行测试，到底多表查询与子查询谁的性能谁更胜一筹。 导入SQL测试数据 官方文档：https://dev.mysql.com/doc/employee/en/ 测试数据库github地址：https://github.com/datacharmer/test_db 1、安装 测试数据使用的是MySQL官方提供的测试数据库，此数据库包含了大约30万的员工数据，280多万条记录，当然所有的数据都是测试数据并非真实数据。数据量并不算多，但用于测试应该是足够了。导入数据也比较简单，首先在github上将test_db-master下载到本地，解压，切换到test_db-master目录，运行mysql -u yourusername -p -t &lt; employees.sql，回车，输入密码即可，类似于下图 图片并没有截全，完整的信息如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445+-----------------------------+| INFO |+-----------------------------+| CREATING DATABASE STRUCTURE |+-----------------------------++------------------------+| INFO |+------------------------+| storage engine: InnoDB |+------------------------++---------------------+| INFO |+---------------------+| LOADING departments |+---------------------++-------------------+| INFO |+-------------------+| LOADING employees |+-------------------++------------------+| INFO |+------------------+| LOADING dept_emp |+------------------++----------------------+| INFO |+----------------------+| LOADING dept_manager |+----------------------++----------------+| INFO |+----------------+| LOADING titles |+----------------++------------------+| INFO |+------------------+| LOADING salaries |+------------------++---------------------+| data_load_time_diff |+---------------------+| 00:01:03 |+---------------------+ 2、测试安装 测试命令如下: 两种测试安装的方法12time mysql -u yourusername -p -t &lt; test_employees_sha.sqltime mysql -u yourusername -p -t &lt; test_employees_md5.sql 以test_employees_sha.sql为例，执行time mysql -u mackvord -p -t &lt; test_employees_sha.sql，显示的信息与官方提供的信息吻合则表示安装没有问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950+----------------------+| INFO |+----------------------+| TESTING INSTALLATION |+----------------------++--------------+------------------+------------------------------------------+| table_name | expected_records | expected_crc |+--------------+------------------+------------------------------------------+| employees | 300024 | 4d4aa689914d8fd41db7e45c2168e7dcb9697359 || departments | 9 | 4b315afa0e35ca6649df897b958345bcb3d2b764 || dept_manager | 24 | 9687a7d6f93ca8847388a42a6d8d93982a841c6c || dept_emp | 331603 | d95ab9fe07df0865f592574b3b33b9c741d9fd1b || titles | 443308 | d12d5f746b88f07e69b9e36675b6067abb01b60e || salaries | 2844047 | b5a1785c27d75e33a4173aaa22ccf41ebd7d4a9f |+--------------+------------------+------------------------------------------++--------------+------------------+------------------------------------------+| table_name | found_records | found_crc |+--------------+------------------+------------------------------------------+| employees | 300024 | 4d4aa689914d8fd41db7e45c2168e7dcb9697359 || departments | 9 | 4b315afa0e35ca6649df897b958345bcb3d2b764 || dept_manager | 24 | 9687a7d6f93ca8847388a42a6d8d93982a841c6c || dept_emp | 331603 | d95ab9fe07df0865f592574b3b33b9c741d9fd1b || titles | 443308 | d12d5f746b88f07e69b9e36675b6067abb01b60e || salaries | 2844047 | b5a1785c27d75e33a4173aaa22ccf41ebd7d4a9f |+--------------+------------------+------------------------------------------++--------------+---------------+-----------+| table_name | records_match | crc_match |+--------------+---------------+-----------+| employees | OK | ok || departments | OK | ok || dept_manager | OK | ok || dept_emp | OK | ok || titles | OK | ok || salaries | OK | ok |+--------------+---------------+-----------++------------------+| computation_time |+------------------+| 00:00:10 |+------------------++---------+--------+| summary | result |+---------+--------+| CRC | OK || count | OK |+---------+--------+real 0m13.565suser 0m0.003ssys 0m0.003s 在shell中进入MySQL模式，查看employees数据库是否安装成功: 查看数据库的基本信息: 查看employees表中所有的字段: 123456789101112mysql&gt; select column_name from information_schema.columns where table_name = &quot;employees&quot;;+-------------+| column_name |+-------------+| emp_no || birth_date || first_name || last_name || gender || hire_date |+-------------+6 rows in set (0.00 sec) 测试在测试之前，我们先看一下employees数据库的表结构图: 通过观察发现，employees表与departments表之间通过dept_emp这张表连接，那么我们通过一个简单的例子来看一下，同样的需求，使用多表关联查询与子查询所耗费的时间。需求:查询每个部门的编号、名称以及部门的人数 多表查询: 12345mysql&gt; select d.dept_no,d.dept_name,count(e.emp_no) count -&gt; from departments d -&gt; left join dept_emp de on d.dept_no = de.dept_no -&gt; right join employees e on e.emp_no = de.emp_no -&gt; group by d.dept_no,d.dept_name; 结果: 子查询: 12345678910mysql&gt; select d.dept_no,d.dept_name,temp.count -&gt; from departments d -&gt; left join ( -&gt; select de.dept_no,count(e.emp_no) count -&gt; from employees e -&gt; left join dept_emp de -&gt; on e.emp_no = de.emp_no -&gt; group by de.dept_no -&gt; ) temp -&gt; on d.dept_no = temp.dept_no; 结果: 以上只是执行单条查询语句所花费的时间，并没有什么说服力，所以接下来，我们换一种测试的方式。 使用mysqlslap测试mysqlslap是mysql官方提供的一个用于模拟服务器负载的工具，使用这个工具可以模拟客户端访问服务器，并输出所花费的时间信息，下面我们就以这个工具为例，再次测试上面的sql语句的执行效果。 1、查看帮助信息，在shell中执行: mysqlslap --help 或者 mysqlslap -? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465--print-defaults 输出参数列表--no-defaults 除登录文件外，不读取任何选项文件的默认选项--defaults-file=# 仅读取给定文件中的默认选项--defaults-extra-file=# 读取全局文件后读取此文件--defaults-group-suffix=# 读取后缀--login-path=# 从登录文件中读取路径 -?, --help 显示帮助信息 -a, --auto-generate-sql 自动生成sql语句 --auto-generate-sql-add-autoincrement 将AUTO_INCREMENT列添加到自动生成的表中 --auto-generate-sql-execute-number=# 指定自动生成的查询数 --auto-generate-sql-guid-primary 将基于GUID的主键添加到自动生成的表中 --auto-generate-sql-load-type=name 指定测试负载类型：mixed，update，write，key或read; 默认是mixed --auto-generate-sql-secondary-indexes=# 在自动生成表时增加二级索引的个数 --auto-generate-sql-unique-query-number=# 为自动测试生成的唯一查询数 --auto-generate-sql-unique-write-number=# 为auto generateql-write-number生成的唯一查询数 --auto-generate-sql-write-number=# 每个线程要执行的插入行的数量（默认值为100） --commit=# 指定在提交前要执行的语句的个数 -C, --compress 压缩客户端和服务器之间发送的所有信息 -c, --concurrency=name 指定模拟查询的客户端数量 --create=name 用于创建数据表的sql语句或包含sql的文件 --create-schema=name 指定运行测试的模式 --csv[=name] 以逗号分割的格式生成输出信息 -#, --debug[=#] 将调试信息写入到日志中 --debug-check 程序退出时打印调试信息 -T, --debug-info 程序退出时打印调试信息，包括内存和CPU统计信息 --default-auth=name 指定默认的身份验证插件 -F, --delimiter=name 指定在sql语句中使用的分隔符 --detach=# 在指定个数的请求之后，关闭并重新打开连接 --enable-cleartext-plugin 启用明文身份验证插件 -e, --engine=name 使用指定的数据库引擎创建数据表 -h, --host=name 连接的主机 -i, --iterations=# 执行测试的次数 --no-drop 测试完后不删除测试表 -x, --number-char-cols=name 自动生成的测试表中包含多少个字符类型的列，默认1 -y, --number-int-cols=name 自动生成的测试表中包含多少个数字类型的列，默认1 --number-of-queries=# 限制执行查询的客户端数量（大约） --only-print 不连接数据库，只打印已执行的相关信息 -p, --password[=name] 连接服务器的密码 --plugin-dir=name 客户端插件的所在目录 -P, --port=# 指定连接数据库的端口 --post-query=name 在运行测试之后，执行查询语句或者包含查询语句的文件 --post-system=name 运行测试之后，使用system()方法输出的字符串 --pre-query=name 在运行测试之前，执行查询语句或者包含查询语句的文件 --pre-system=name 在运行测试之前使用system()方法输出的字符串 --protocol=name 指定使用的连接协议(tcp, socket, pipe,memory) -q, --query=name 执行查询语句或者包含查询语句的文件 --secure-auth 如果客户端使用4.1.1版本之前的协议将被拒绝连接到服务器，已废弃，始终为true -s, --silent 以静默模式运行程序 - 无输出 -S, --socket=name 用于连接的套接字文件 --sql-mode=name 指定运行mysqlslap工具的sql模式 --ssl-mode=name SSL 连接模式 --ssl 已废弃，可以使用 --ssl-mode 代替，注意此选项默认是开启的，可以使用 --skip-ssl 关闭 --ssl-verify-server-cert 已废弃，使用 --ssl-mode=VERIFY_IDENTITY 代替 --ssl-ca=name 包含受信任的SSL证书颁发机构证书文件的目录 --ssl-capath=name CA（受信任的证书颁发机构）目录 --ssl-cert=name PEM格式的X509证书 --ssl-cipher=name SSL密码 --ssl-key=name PEM格式的X.509密钥 --ssl-crl=name 包含证书吊销列表的文件 --ssl-crlpath=name 包含证书吊销列表文件的目录 --tls-version=name 指定TLS协议的版本，可选值: TLSv1, TLSv1.1 -u, --user=name 指定登录用户 -v, --verbose 输出详细信息 -V, --version 输出版本信息并退出 2、模拟50个客户端，500次并发连接请求 多表查询: 执行以下语句: 12345678mysqlslap -h localhost -P 3306 --concurrency=50 --number-of-queries=500 --create-schema='employees' --query='select d.dept_no,d.dept_name,count(e.emp_no) count from departments d left join dept_emp de on d.dept_no = de.dept_no right join employees e on e.emp_no = de.emp_no group by d.dept_no,d.dept_name;' -u mackvord -p 子查询: 执行以下语句: 1234567891011mysqlslap -h localhost -P 3306 --concurrency=50 --number-of-queries=500 --create-schema='employees' --query='select d.dept_no,d.dept_name,temp.count from departments d left join ( select de.dept_no,count(e.emp_no) count from employees e left join dept_emp de on e.emp_no = de.emp_no group by de.dept_no ) temp on d.dept_no = temp.dept_no;' -u mackvord -p 通过两次执行的结果来看，多表查询用了将近5分钟，而子查询用了3分钟多一点，虽然两次查询的速度都有点慢，但是貌似子查询的速度要快一点？这样下结论好像太草率了，毕竟这只是查询每个部门的编号、名称以及部门的人数，对于其他的不同需求，可能编写的sql语句就不一样，那么执行的性能也会有所差异，所以还得看具体问题。OK，文章到此就告一段落了，有时间再继续补充吧。]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>多表查询</tag>
        <tag>子查询</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Vue-cli构建web项目]]></title>
    <url>%2Fvue%2F43330.html</url>
    <content type="text"><![CDATA[linux下使用vue脚手架工具vue-cli构建web项目 写在前面 vue官网 安装vue-cli1、安装Node.js环境 vue-cli是vue官方提供的一个用于快速构建单页应用的脚手架工具，在安装之前首先要确保已经安装了node.js和npm,npm也是官方推荐的用于构建大型应用的包管理工具。你可以使用以下命令查看是否已经成功安装了Node.js和npm[1]。 12node -vnpm -v 2、vue-cli 全局安装vue-cli,执行npm install vue-cli --global，安装完成后检查是否安装成功，输入:vue -V[2]查看vue的版本信息，如果能看到vue的版本信息，表示成功了，如果显示bash: vue command not found，则需要建立软连接，以deepin系统为例，执行以下命令建立软连接: 12sudo ln -s /opt/node-v8.11.4-linux-x64/bin/vue /usr/local/bin/vue## /opt/node-v8.11.4-linux-x64/bin/vue是上面vue-cli的安装位置，需要根据自己的安装路径调整 接下来我们要初始化项目，使用命令vue init webpack your-project-name，这里注意要切换到自己想要放置项目文件的目录下，在安装的过程中可能会要求输入一些信息，比如项目的名称、描述、作者、是否使用路由等等，这些根据自己的需要设置即可。 安装完成后，根据提示，输入npm run dev运行项目 最后测试一下vue-cli是否安装成功，在浏览器输入地址:http://localhost:8080，如果能在浏览器看到以下页面，说明安装没问题。 安装element-ui组件element-ui是由饿了么前端团队推出的基于vue2.0的UI组件，非常简洁、漂亮。在vue项目中引入element-ui非常简单，你可以使用npm在项目中安装element-ui，也可以使用CDN外链，直接在页面上引入相应的js和css，两种方式都能够在项目中正常使用element-ui组件。以npm安装为例，切换到项目路径下，执行npm install element-ui安装element-ui: 1.在安装Node.js时，npm也会被安装，所以无需额外安装npm ↩2.注意V要大写 ↩]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客迁移到deepin]]></title>
    <url>%2Fhexo%2F105449622.html</url>
    <content type="text"><![CDATA[博客迁移到Deepin系统 写在前面 deepin官网 最近由于自己使用的window系统版本即将停止维护，360一天到晚地提示我更新到最新版本，而恰巧最近又回到学校了，因为学校网络限速的问题，自己也没办法更新window系统，这时候才想起之前早已经就下载好的deepin系统，之前因为各种各样的原因，一直都没有安装。所以便决定在自己的本子上安装deepin系统，之前玩Linux都是在虚拟机上，从来都没有在物理机上使用过Linux，这一次算是真正可以体验Linux的魅力了。至于为什么选择deepin而不是ubuntu或者manjaro等等其他的Linux发行版，我想最主要的原因还是deepin是国产的Linux操作系统，符合国人的使用习惯，而且deepin的UI也做得相当不错，毕竟除了实力，颜值还是要考虑的。安装的过程我就不说了，满满的都是泪啊~~，踩了不少坑，而且装好系统之后配置各种开发环境也花了不少的时间，总之，希望deepin经得住折腾，别挂就行！ 迁移博客关于博客迁移，虽然自己在安装deepin之前已经将数据备份好了，但是由于之前搭建博客的时候修改了不少源码，导致博客在迁移的时候变得相当麻烦，基本上相当于重构一遍，可见硬编码问题是有多恐怖，所以这一次在迁移博客的时候，基本上能不改源码的地方就不改，所有的样式尽可能在自定义的配置文件中配置，而且这一次自己也针对移动端的显示效果进行的一些调整，总而言之，就当做是重新优化一下博客，顺便学习一下Linux的相关知识吧。 文章推荐关于hexo博客的优化，可以参考我的另一篇文章: HEXO-NexT-Github-Pages]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>deepin</tag>
        <tag>hexo</tag>
        <tag>迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Solr 7.4.0与Tomcat 9.0.11整合]]></title>
    <url>%2Fenvironment%2F2593381883.html</url>
    <content type="text"><![CDATA[同一台机器部署多个Tomcat、Solr与Tomcat整合的部分配置 写在前面由于本人的机子上已经安装过Tomcat 9.0.10，为了不影响已有的Tomcat服务器，所以决定再安装一个Tomcat用于部署Solr，所用的Tomcat服务器和Solr索引库目前都是最新版的，也就是Tomcat 9.0.11和Solr 7.4.0。 环境准备 Tomcat服务器：Tomcat 9.0.11 Solr索引库：Solr 7.4.0 Tomcat和Solr可自行到相应的官网上下载，版本根据自己的需要选择，下载完成后解压如下： 配置多个Tomcat配置环境变量Location：我的电脑 &gt;&gt; 计算机 &gt;&gt; 属性 &gt;&gt; 高级系统设置 &gt;&gt; 环境变量 &gt;&gt; 系统变量 1234CATALINA_HOMECATALINA_BASETOMCAT_HOMEPath 由于我已经配置了一个Tomcat，所以在下面的配置中，所有涉及的环境变量我都会配置为Xxx3的形式，即： 123CATALINA_HOME3CATALINA_BASE3TOMCAT_HOME3 配置CATALINA_HOME3，默认情况下是CATALINA_HOME 配置Path，新增%CATALINA_HOME3%\bin 配置CATALINA_BASE3，默认情况下是CATALINA_BASE3 配置TOMCAT_HOME3，默认情况下是TOMCAT_HOME 修改脚本文件，文件所在路径：F:\Solr And Tomcat\apache-tomcat-9.0.11\bin123456789101112131、修改catalina.bat文件 环境变量配置好之后，需要修改`F:\Solr And Tomcat\apache-tomcat-9.0.11\bin`目录下的`catalina.bat`文件，使用`Notepad++`或者其他的文本编辑器将所有的`CATALINA_HOME`替换为`CATALINA_HOME3`；所有的`CATALINA_BASE`替换为`CATALINA_BASE3`，保存退出。2、修改startup.bat文件 与修改catalina.bat文件类似，将所有的`CATALINA_HOME`替换为`CATALINA_HOME3`，保存退出3、修改shutdown.bat文件 将所有的`CATALINA_HOME`替换为`CATALINA_HOME3`，保存退出 修改server.xml修改Tomcat的核心配置文件，主要是修改默认的访问端口、JVM启动端口以及shutdown端口 12345678910- &lt;Server port="8005" shutdown="SHUTDOWN"&gt;+ &lt;Server port="8007" shutdown="SHUTDOWN"&gt;- &lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt;+ &lt;Connector port="8083" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt;- &lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt;+ &lt;Connector port="8011" protocol="AJP/1.3" redirectPort="8443" /&gt;注意：-表示修改原始的配置、+表示修改后的配置，修改后的端口号可以自定义，但是不能与其他端口号冲突 测试 整合SolrSolr的目录结构 导入demo 将F:\Solr And Tomcat\solr-7.4.0\server\solr-webapp下的webapp文件夹复制到F:\Solr And Tomcat\apache-tomcat-9.0.11\webapps目录下，重命名为solr（名字可自定义） 导入jar包 复制F:\Solr And Tomcat\solr-7.4.0\server\lib\ext下的所有jar包到F:\Solr And Tomcat\apache-tomcat-9.0.11\webapps\solr\WEB-INF\lib下，如果jar包重复可选择跳过或者覆盖；复制F:\Solr And Tomcat\solr-7.4.0\server\lib下所有metrics开头的jar包以及gmetric4j-1.0.7.jar到F:\Solr And Tomcat\apache-tomcat-9.0.11\webapps\solr\WEB-INF\lib下。 创建solrhome 创建solrhome文件夹，位置自定义，复制F:\Solr And Tomcat\solr-7.4.0\server\solr下的所有文件到新建的solrhome文件夹中 修改F:\Solr And Tomcat\apache-tomcat-9.0.11\webapps\solr\WEB-INF路径下的web.xml文件 默认的配置1234567&lt;!--&lt;env-entry&gt; &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt; &lt;env-entry-value&gt;/put/your/solr/home/here&lt;/env-entry-value&gt; &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;&lt;/env-entry&gt;--&gt; 修改后：123456&lt;env-entry&gt; &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt; &lt;!-- 此处填写solrhome所在的路径 --&gt; &lt;env-entry-value&gt;F:\Solr And Tomcat\solrhome&lt;/env-entry-value&gt; &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;&lt;/env-entry&gt; 注释掉安全约束的配置1234567891011121314151617&lt;!--&lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;Disable TRACE&lt;/web-resource-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;http-method&gt;TRACE&lt;/http-method&gt; &lt;/web-resource-collection&gt; &lt;auth-constraint/&gt; &lt;/security-constraint&gt; &lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;Enable everything but TRACE&lt;/web-resource-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;http-method-omission&gt;TRACE&lt;/http-method-omission&gt; &lt;/web-resource-collection&gt;&lt;/security-constraint&gt;--&gt; 修改solrconfig.xml 复制F:\Solr And Tomcat\solr-7.4.0目录下的dist文件夹和contrib文件夹到F:\Solr And Tomcat\solrhome目录下，这样做的主要因为Solr加载第三方插件的路径配置是这样的： solrconfig.xml1234567891011&lt;lib dir="$&#123;solr.install.dir:../../../..&#125;/contrib/extraction/lib" regex=".*\.jar" /&gt;&lt;lib dir="$&#123;solr.install.dir:../../../..&#125;/dist/" regex="solr-cell-\d.*\.jar" /&gt;&lt;lib dir="$&#123;solr.install.dir:../../../..&#125;/contrib/clustering/lib/" regex=".*\.jar" /&gt;&lt;lib dir="$&#123;solr.install.dir:../../../..&#125;/dist/" regex="solr-clustering-\d.*\.jar" /&gt;&lt;lib dir="$&#123;solr.install.dir:../../../..&#125;/contrib/langid/lib/" regex=".*\.jar" /&gt;&lt;lib dir="$&#123;solr.install.dir:../../../..&#125;/dist/" regex="solr-langid-\d.*\.jar" /&gt;&lt;lib dir="$&#123;solr.install.dir:../../../..&#125;/contrib/velocity/lib" regex=".*\.jar" /&gt;&lt;lib dir="$&#123;solr.install.dir:../../../..&#125;/dist/" regex="solr-velocity-\d.*\.jar" /&gt; 这个配置文件默认是在F:\Solr And Tomcat\solr-7.4.0\server\solr\configsets\_default\conf目录下，由于在配置solrhome的时候我们将原来的配置文件拷贝到了solrhome文件夹中，所以要修改原来的路径配置，如果dist、contrib与新建的core（collection）位于同一目录下，用一个..即可。 测试整合运行startup.bat脚本启动Tomcat，访问：http://localhost:8083/solr/index.html 导入数据引入jar包以及资源文件由于用到了IKAnalyzer分词器，所以需要导入相应的jar包（ikanalyzer-2012_u6.jar），包下载地址：http://mvnrepository.com/artifact/com.janeluo/ikanalyzer/2012_u6，将ikanalyzer-2012_u6.jar分别复制到~\solrhome\contrib\extraction\lib和~\apache-tomcat-9.0.11\webapps\solr\WEB-INF\lib目录下。并且将以下三个jar包复制到~\solrhome\collection2\lib目录下。 12345// 数据库驱动包mysql-connector-java-8.0.11.jar// Solr自带的数据导入相关的jar包，默认位于~\solr-7.4.0\dist目录下solr-dataimporthandler-7.4.0.jarsolr-dataimporthandler-extras-7.4.0.jar 注意：IKAnalyzer分词器的作者在几年前就已经停止维护这个项目了，这就意味如果你使用的是新版本Solr可能会存在兼容性问题，问题我在文章末尾已经提到。当然，如果你对IKAnalyzer分词器这个项目感兴趣，你可以尝试着去改进它，或者使用别人已经改进过的版本。 导入jar包后还需要将IKAnalyzer分词器相关的资源文件拷贝到~\apache-tomcat-9.0.11\webapps\solr\WEB-INF\classes目录下，如果没有classes目录则需要自己手动创建一个。 相关的资源文件123ext.dicIKAnalyzer.cfg.xmlstopword.dic 修改solrconfig.xml文件在solrconfig.xml添加以下配置，db-data-config.xml文件名可自定义，但必须与solrconfig.xml位于同级目录下 solrconfig.xml12345&lt;requestHandler name="/dataimport" class="org.apache.solr.handler.dataimport.DataImportHandler"&gt; &lt;lst name="defaults"&gt; &lt;str name="config"&gt;db-data-config.xml&lt;/str&gt; &lt;/lst&gt;&lt;/requestHandler&gt; 修改managed-schema文件修改managed-schema文件，添加如下配置 managed-schema123456789101112131415161718&lt;!-- IkAnalyzer --&gt;&lt;fieldType name="text_ik" class="solr.TextField"&gt; &lt;analyzer class="org.wltea.analyzer.lucene.IKAnalyzer" /&gt;&lt;/fieldType&gt;&lt;!-- IkAnalyzer field --&gt;&lt;filed name="title_ik" type="text_ik" indexed="true" stored="true" /&gt;&lt;filed name="content_ik" type="text_ik" indexed="true" stored="false" multiValue="true" /&gt;&lt;!-- 添加与数据库表字段对应的field --&gt; &lt;field name="item_title" type="string" indexed="true" stored="true" /&gt;&lt;field name="item_price" type="pfloat" indexed="true" stored="true" /&gt;&lt;field name="item_num" type="string" indexed="true" stored="true" /&gt;&lt;field name="item_image" type="string" indexed="true" stored="true" /&gt;&lt;!-- 配置copyField，优化搜索 --&gt;&lt;field name="item_keyworks" type="text_ik" indexed="ture" stored="false" multiValued="ture" /&gt;&lt;copyField source="item_title" dest="item_keyworks" /&gt;&lt;copyField source="item_price" dest="item_keyworks" /&gt; 修改db-data-config.xml文件修改db-data-config.xml文件，添加如下配置 db-data-config.xml123456789101112131415161718&lt;dataConfig&gt; &lt;!-- 配置数据库的连接信息 --&gt; &lt;dataSource name="dataSource" type="JdbcDataSource" driver="com.mysql.cj.jdbc.Driver" url="jdbc:mysql://localhost:3306/lucene?useSSL=false&amp;amp;serverTimezone=GMT%2B8" user="mackvord" password="12345678"/&gt; &lt;document&gt; &lt;entity name="item" dataSource="dataSource" query="SELECT id,title,price,num,image FROM tb_item"&gt; &lt;!-- column表示数据库表字段名，name属性的值对应于managed-schema中的field --&gt; &lt;field column="id" name="id" /&gt; &lt;field column="title" name="item_title" /&gt; &lt;field column="price" name="item_price" /&gt; &lt;field column="num" name="item_num" /&gt; &lt;field column="image" name="item_image" /&gt; &lt;/entity&gt; &lt;/document&gt;&lt;/dataConfig&gt; 测试 通过观察发现，数据并没有导入成功，无法成功创建索引，一直显示：Requests: 1 , Fetched: 3,096 774/s, Skipped: 0 , Processed: 0，自己也在网上查找了很久，尝试了很多方法但都没能解决这个问题，查看日志，也没发现有异常信息，自己也一度认为是因为最新版本的原因，导致数据始终无法成功导入，过了一天，再次尝试导入数据的时候，控制台居然报了个错：solr Exception in thread &quot;Thread-7&quot; java.lang.AbstractMethodError咋一看应该是分词器的问题，初步猜测应该是IKAnalyzer分词器的版本问题，因为IKAnalyzer已经相当长时间都没有更新的，随后在网上找到了一个据说是能够兼容6.x版本的Lucene的IKAnalyzer分词器，Github 地址，自己download下来，导入了lucene-core-7.4.0.jar和lucene-queryparser-7.4.0.jar两个jar包后重新打成Jar包，替换掉原来的ikanalyzer-2012_u6.jar，之后重新启动Tomcat，导入数据成功。 效果: 查询数据：]]></content>
      <categories>
        <category>environment</category>
      </categories>
      <tags>
        <tag>整合</tag>
        <tag>Solr 7.4.0</tag>
        <tag>多Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lucene基础篇]]></title>
    <url>%2Flucene%2F1593899620.html</url>
    <content type="text"><![CDATA[Lucene入门、创建索引库、基本的增删改查 Lucene简介 Lucene官网Lucene是Apache软件基金会的一个开源项目，是一个高性能的信息检索库，可用于需要全文索引和搜索功能的任何应用程序。Lucene最初由Doug Cutting开发，后来并入Jakarta，成为Jakarta的一个子项目。关于更多Lucene的信息，请查看wikipedia Lucene工具Luke Download地址：https://github.com/DmitryKey/luke/releasesluke是一款Lucene/Solr的图形化工具，使用Luke可以方便地查看并分析文档中的字段内容，进行索引维护以及检查索引的运行状况等。想了解更多关于Luke的信息可以参考：https://github.com/DmitryKey/luke 创建索引库123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.my.lucene;import java.io.File;import java.io.IOException;import java.nio.file.Paths;import org.apache.commons.io.FileUtils;import org.apache.lucene.analysis.Analyzer;import org.apache.lucene.analysis.standard.StandardAnalyzer;import org.apache.lucene.document.Document;import org.apache.lucene.document.Field;import org.apache.lucene.document.StoredField;import org.apache.lucene.document.TextField;import org.apache.lucene.document.Field.Store;import org.apache.lucene.index.IndexWriter;import org.apache.lucene.index.IndexWriterConfig;import org.apache.lucene.store.Directory;import org.apache.lucene.store.FSDirectory;import org.junit.Test;/** * Lucene入门，创建索引库 * @author Mackvord * @date 2018年8月30日 * @version 1.0 */public class LuceneTest &#123; /** * 测试创建索引库 * @throws IOException */ @Test public void createIndexTest() throws IOException &#123; // 创建Directory对象，指定索引库的存放位置 Directory directory = FSDirectory.open(Paths.get("F:/", "TestLucene")); // 创建标准分词器 Analyzer analyzer = new StandardAnalyzer(); // 创建索引配置对象 IndexWriterConfig config = new IndexWriterConfig(analyzer); // 创建indexwriter对象,指定一个路径和配置 IndexWriter indexwriter = new IndexWriter(directory, config); // 创建filed对象，将file对象添加到document对象中 File file = new File("F:\\searchSource"); File[] listFiles = file.listFiles(); for (File f : listFiles) &#123; // 创建Document对象 Document document = new Document(); // 文件名称域 Field fileNameField = new TextField("fileName", f.getName(), Store.YES); // 文件大小域 Field fileSizeField = new TextField("fileSize", String.valueOf(FileUtils.sizeOf(f)), Store.YES); // 文件路径域 Field filePathField = new StoredField("filePath", f.getPath()); // 文件内容域 Field fileContentField = new TextField("fileContent", FileUtils.readFileToString(f,"UTF-8"), Store.YES); // 将域属性添加到文档对象中 document.add(fileNameField); document.add(fileSizeField); document.add(filePathField); document.add(fileContentField); // 使用indexwriter对象将document对象写入索引库中 indexwriter.addDocument(document); &#125; // 关闭资源 indexwriter.close(); &#125;&#125; Lucene简单查询12345678910111213141516171819202122232425262728293031/** * 测试简单搜索：根据域名和域值搜索 * @throws IOException */@Testpublic void searchTest() throws IOException &#123; // 1.创建Directory对象，即索引库的存放位置 Directory directory = FSDirectory.open(Paths.get("F:/", "TestLucene")); // 2.创建IndexReader对象，指定Directory对象 IndexReader indexReader = DirectoryReader.open(directory); // 3.创建IndexSearcher对象，指定indexReader对象 IndexSearcher indexSearcher = new IndexSearcher(indexReader); // 4.创建术语查询对象（TermQuery），指定查询的域和其对应的值 Query query = new TermQuery(new Term("fileName", "readme.txt")); // 5.执行查询(查询两条记录) TopDocs topDocs = indexSearcher.search(query, 2); // 6.获取文档id集合,遍历查询结果并输出 ScoreDoc[] scoreDocs = topDocs.scoreDocs; for (ScoreDoc scoreDoc : scoreDocs) &#123; // 获取文档id int id = scoreDoc.doc; // 创建Document对象 Document document = indexSearcher.doc(id); // 取出域值 System.out.println(document.get("fileName")); System.out.println(document.get("fileSize")); System.out.println(document.get("fileContent")); System.out.println(document.get("filePath")); &#125; indexReader.close();&#125; 基本的增删改查以下是Lucene的一些基本的增删改查操作，主要是熟悉一下API 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203package com.my.lucene;import java.io.IOException;import java.nio.file.Paths;import org.apache.lucene.analysis.Analyzer;import org.apache.lucene.analysis.standard.StandardAnalyzer;import org.apache.lucene.document.Document;import org.apache.lucene.document.Field.Store;import org.apache.lucene.document.TextField;import org.apache.lucene.index.DirectoryReader;import org.apache.lucene.index.IndexReader;import org.apache.lucene.index.IndexWriter;import org.apache.lucene.index.IndexWriterConfig;import org.apache.lucene.index.Term;import org.apache.lucene.queryparser.classic.MultiFieldQueryParser;import org.apache.lucene.queryparser.classic.ParseException;import org.apache.lucene.queryparser.classic.QueryParser;import org.apache.lucene.search.BooleanClause.Occur;import org.apache.lucene.search.BooleanQuery;import org.apache.lucene.search.BooleanQuery.Builder;import org.apache.lucene.search.IndexSearcher;import org.apache.lucene.search.MatchAllDocsQuery;import org.apache.lucene.search.Query;import org.apache.lucene.search.ScoreDoc;import org.apache.lucene.search.TermQuery;import org.apache.lucene.search.TermRangeQuery;import org.apache.lucene.search.TopDocs;import org.apache.lucene.store.Directory;import org.apache.lucene.store.FSDirectory;import org.junit.Test;/** * 索引管理、基本的增删改查 * @author Mackvord * @date 2018年8月26日 * @version 1.0 */public class LuceneManager &#123; /** * 获取IndexWriter对象的方法 * @return * @throws IOException */ public IndexWriter getIndexWriter() throws IOException &#123; // 创建Directory对象 Directory directory = FSDirectory.open(Paths.get("F:/", "TestLucene")); Analyzer analyzer = new StandardAnalyzer(); IndexWriterConfig config = new IndexWriterConfig(analyzer); return new IndexWriter(directory, config); &#125; /** * 获取IndexSearcher对象 * @return IndexSearcher * @throws IOException */ public IndexSearcher getIndexSearcher() throws IOException &#123; // 1.创建Directory对象，即索引库的存放位置 Directory directory = FSDirectory.open(Paths.get("F:/", "TestLucene")); // 2.创建IndexReader对象，指定Directory对象 IndexReader indexReader = DirectoryReader.open(directory); // 3.创建IndexSearcher对象，指定indexReader对象 return new IndexSearcher(indexReader); &#125; /** * 测试删除所有索引 * @throws IOException */ @Test public void deleteAllTest() throws IOException &#123; IndexWriter indexWriter = getIndexWriter(); indexWriter.deleteAll(); indexWriter.close(); &#125; /** * 测试根据条件删除 * @throws IOException */ @Test public void deleteTest() throws IOException &#123; IndexWriter indexWriter = getIndexWriter(); Query query = new TermQuery(new Term("fileName","readme")); indexWriter.deleteDocuments(query); indexWriter.close(); &#125; /** * 测试修改 * @throws IOException */ @Test public void updateTest() throws IOException &#123; IndexWriter indexWriter = getIndexWriter(); Document doc = new Document(); doc.add(new TextField("Name", "测试名", Store.YES)); doc.add(new TextField("Content", "测试内容", Store.YES)); indexWriter.updateDocument(new Term("fileName", "readme.txt"), doc); indexWriter.close(); &#125; public void printResult(IndexSearcher indexSearcher, Query query) throws IOException &#123; // 执行查询(查询两条记录) TopDocs topDocs = indexSearcher.search(query, 2); // 获取文档id集合,遍历查询结果并输出 ScoreDoc[] scoreDocs = topDocs.scoreDocs; for (ScoreDoc scoreDoc : scoreDocs) &#123; // 获取文档id int id = scoreDoc.doc; // 创建Document对象 Document document = indexSearcher.doc(id); // 取出域值 System.out.println(document.get("fileName")); System.out.println(document.get("fileSize")); System.out.println(document.get("fileContent")); System.out.println(document.get("filePath")); &#125; &#125; /** * 测试查询所有 * @throws IOException */ @Test public void MatchAllDocsQueryTest() throws IOException &#123; IndexSearcher indexSearcher = getIndexSearcher(); Query query = new MatchAllDocsQuery(); printResult(indexSearcher, query); indexSearcher.getIndexReader().close(); &#125; /** * 测试根据范围查询 * @throws IOException */ @Test public void TermRangeQueryTest() throws IOException &#123; IndexSearcher indexSearcher = getIndexSearcher(); Query query = TermRangeQuery.newStringRange("fileSize", String.valueOf(400), String.valueOf(800), true, true); printResult(indexSearcher, query); indexSearcher.getIndexReader().close(); &#125; /** * 测试组合查询 * @throws IOException */ @Test public void BooleanQueryTest() throws IOException &#123; IndexSearcher indexSearcher = getIndexSearcher(); Query query1 = new TermQuery(new Term("fileName", "readme.txt")); Query query2 = new TermQuery(new Term("fileName", ".txt")); // Occur.MUST: 必须有 // Occur.SHOULD: 可有可无 // Occur.MUST_NOT: 必须没有 Builder builder = new Builder(); builder.add(query1, Occur.MUST); builder.add(query2, Occur.SHOULD); BooleanQuery booleanQuery = builder.build(); printResult(indexSearcher, booleanQuery); &#125; /** * 解析查询 * @throws IOException * @throws ParseException */ @Test public void QueryParserTest() throws IOException, ParseException &#123; IndexSearcher indexSearcher = getIndexSearcher(); // 第一个参数为默认查询的域，第二个参数为指定的分词器 QueryParser queryParser = new QueryParser("fileName", new StandardAnalyzer()); // 指定解析查询的表达式(域:值),如果表达式中的域与上面设置的默认域不一致，那么查询的是表达式中的域，*:*表示查询所有，+表示必须满足，-表示必须不满足 Query query = queryParser.parse("fileName:readme.txt"); printResult(indexSearcher, query); // 打印查询语句 System.out.println(query); indexSearcher.getIndexReader().close(); &#125; /** * 多条件解析查询（多个默认域） * @throws IOException * @throws ParseException */ @Test public void MultiFieldQueryParserTest() throws IOException, ParseException &#123; IndexSearcher indexSearcher = getIndexSearcher(); // 域数组 String[] fields = &#123;"fileName", "fileSize"&#125;; // 第一个参数为默认查询的域，第二个参数为指定的分词器 MultiFieldQueryParser multiFieldQueryParser = new MultiFieldQueryParser(fields, new StandardAnalyzer()); // 指定解析查询的表达式(域:值),如果表达式中的域与上面设置的默认域不一致，那么查询的是表达式中的域，*:*表示查询所有，+表示必须满足，-表示必须不满足 Query query = multiFieldQueryParser.parse("readme.txt"); printResult(indexSearcher, query); // 打印查询语句 System.out.println(query); indexSearcher.getIndexReader().close(); &#125;&#125; 结束语以上仅仅算是Lucene的入门操作，要深入学习Lucene相关的知识还需要日后慢慢积累，有时间在继续补充！]]></content>
      <categories>
        <category>lucene</category>
      </categories>
      <tags>
        <tag>Lucene</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC-Mybatis整合]]></title>
    <url>%2Fssm%2F3221413095.html</url>
    <content type="text"><![CDATA[SpringMVC与Mybatis整合过程及部分配置 导包关于导包，如果是Maven项目，直接在pom文件中配置，会自动在私服或者maven的中央仓库中下载。而这里采用是手动导入jar包的方式。 Spring相关的jar包 mybatis相关的jar包 其他jar包：驱动、连接池等 导约束导入约束这部分方法我在Struts2这篇文章中介绍过，方法是一样的，这里就不再赘述，用到相关的约束如下： 约束文件12345678spring-beans.xsdspring-context.xsdspring-aop.xsdspring-tx.xsdspring-mvc.xsdmybatis-3-mapper.dtdmybatis-3-config.dtd... 配置applicationContext.xmlapplicationContext.xml是Spring的核心配置文件，主要负责对象的管理、事务的管理，当然也包括配置数据库连接 applicationContext.xml123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 配置数据库连接资源文件的路径 --&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;!-- 配置数据库连接池 --&gt; &lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置mybatis的sqlSessionFactory工厂 --&gt; &lt;bean name="sqlSessionFactoryBean" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 注入连接池 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 配置mybatis核心配置文件的位置 --&gt; &lt;property name="configLocation" value="classpath:sqlMapConfig.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 扫描注解 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 指定一个基本包，spring会自动扫描包下的所有mapper接口 --&gt; &lt;property name="basePackage" value="com.my.springmvc.dao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置注解事务 --&gt; &lt;bean name="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 启用注解事务 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;&lt;/beans&gt; 配置db.propertiesdb.properties文件主要是配置数据库的连接信息，以mysql数据库为例： db.properties1234jdbc.driverClass=com.mysql.cj.jdbc.Driverjdbc.jdbcUrl=jdbc:mysql://localhost:3306/springmvc?useSSL=false&amp;serverTimezone=GMT%2B8jdbc.user=mackvordjdbc.password=12345678 配置springmvc.xmlspringmvc.xml文件是SpringMVC框架表现层的核心配置文件，主要进行映射处理器、适配处理器、视图解析器等组件的相关配置。 springmvc.xml123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package="com.my" /&gt; &lt;!-- 配置映射处理器 --&gt; &lt;!-- &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping" /&gt; --&gt; &lt;!-- 配置适配处理器 --&gt; &lt;!-- &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter" /&gt; --&gt; &lt;!-- 开启注解驱动，配置了注解驱动，就无需再手动配置新版映射处理器和适配处理器，如果想要配置前后缀，还需要手动配置视图解析器 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 配置前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"&gt;&lt;/property&gt; &lt;!-- 配置后缀 --&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 配置web.xmlweb.xml整个web项目的配置文件，在这个文件中需要配置Spring容器随项目的启动而创建，即配置Spring监听器，同时还要配置SpringMVC的前端控制器… web.xml123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;SpringMVC-Mybatis&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 配置Spring监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置springmvc前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 配置拦截的路径 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 配置SqlMapConfig.xmlSqlMapConfig.xml是mybatis的核心配置文件，下面是在此文件中配置别名： SqlMapConfig.xml12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 设置别名 --&gt; &lt;typeAliases&gt; &lt;package name="com.my.springmvc.pojo"/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt;]]></content>
      <categories>
        <category>ssm</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>Mybatis</tag>
        <tag>整合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis基础篇]]></title>
    <url>%2Fmybatis%2F2249000879.html</url>
    <content type="text"><![CDATA[Mybatis的基本认识，映射文件、核心配置文件的配置 Mybatis简介 Mybatis官方文档MyBatis是目前最为流行的持久层框架之一，相比于Hibernate框架，Mybatis更容易使用，并且支持定制SQL语句，存储过程以及高级映射。 Mybatis入门要使用mybatis只需要导入mybatis-x.x.x.jar包即可，包下载地址：http://mvnrepository.com，使用mybatis需要对映射文件以及核心配置文件进行相关的配置。Mybatis要操作数据库需要配置SqlSessionFactory，利用工厂对象来获取sqlSession对象。SqlSessionFactory可以在xml文件中配置，也可以直接在Java类中配置。 在XML文件中配置SqlSessionFactory 关于在xml中配置SqlSessionFactory官方文档上是这样说的： The configuration XML file contains settings for the core of the MyBatis system, including aDataSource for acquiring database Connection instances, as well as a TransactionManager fordetermining how transactions should be scoped and controlled. 也就是说我们需要配置数据库连接的数据源dataSource以及事务管理器，例如： mybatis-config.xml12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 读取数据库连接资源文件 --&gt; &lt;properties resource="db.properties" /&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用JDBC管理事务 --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 配置数据库连接池 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;!-- 引入SQL映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource="org/mybatis/example/XxxMapper.xml"/&gt; &lt;/mappers&gt; &lt;/environments&gt;&lt;/configuration&gt; 当然，这只是最基本的操作，事实上如果mybatis与spring整合了，那么关于数据库连接这一块的配置在Spring的配置文件中进行配置更加合理，这仅仅是一个简单的例子。进行了数据库连接相关的配置之后，就可以在Java类（DAO）中读取配置文件并创建SqlSessionFactory工厂了: 在类中加载资源文件12345678// 声明资源文件的位置（这里配置在src路径下）String resource = "mybatis-config.xml";// 读取资源文件InputStream in = Resources.getResourceAsStream(resource);// 创建SqlSessionFactory工厂SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in);// 获取session SqlSession sqlSession = sessionFactory.openSession(); 不使用XML构建SqlSessionFactory 在查阅官方文档的时候，关于不使用XML构建SqlSessionFactory的方法，官方给出来如下代码： 123456+ DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();TransactionFactory transactionFactory = new JdbcTransactionFactory();Environment environment = new Environment("development", transactionFactory, dataSource);Configuration configuration = new Configuration(environment);configuration.addMapper(BlogMapper.class);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration); 代码中用到了一个BlogDataSourceFactory，本来我估计是一个接口，但当我去查看源码的时候，发现好像并没有一个叫BlogDataSourceFactory的类或者接口。关于DataSource这一部分的包结构如下： 可以发现，mybatis提供了三种不同类型的数据源工厂类型：JndiDataSourceFactory、PooledDataSourceFactory、UnpooledDataSourceFactory，这三个类都是DataSourceFactory接口的实现类，这意味着我们可以创建三种不同类型的数据源，当然最为常用的肯定是连接池类型的数据源，即:PooledDataSourceFactory类，以这个类为例，不使用XMl文件来构建SqlSessionFactory： 12345678910111213141516171819202122// 创建资源对象 Properties properties = new Properties();// 设置属性properties.setProperty("driver", "com.mysql.cj.jdbc.Driver");properties.setProperty("url", "jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;serverTimezone=GMT%2B8");properties.setProperty("username", "mackvord");properties.setProperty("password", "12345678");// 创建连接池工厂DataSourceFactory dataSourceFactory = new PooledDataSourceFactory();dataSourceFactory.setProperties(properties);// 获取数据源DataSource dataSource = dataSourceFactory.getDataSource();// 创建事务工厂TransactionFactory transactionFactory = new JdbcTransactionFactory();// 创建Environment对象Environment environment = new Environment("development", transactionFactory, dataSource);// 创建Configuration对象Configuration configuration = new Configuration(environment);// 添加映射类configuration.addMapper(UserMapper.class);// 创建SqlSessionFactorySqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration); Mybatis XML映射文件 在xml映射文件中一共有9个元素：&ensp;&ensp;&ensp;&ensp;1、cache - 配置给定命名空间的缓存。&ensp;&ensp;&ensp;&ensp;2、cache-ref – 从其他命名空间引用缓存配置。&ensp;&ensp;&ensp;&ensp;3、resultMap – 最复杂，也是最强大的元素，用来描述如何从数据库结果集中来加载你的对象。&ensp;&ensp;&ensp;&ensp;4、parameterMap – 已废弃！&ensp;&ensp;&ensp;&ensp;5、sql – 可以重用的 SQL 块，也可以被其他语句引用。&ensp;&ensp;&ensp;&ensp;6、insert – 映射插入语句&ensp;&ensp;&ensp;&ensp;7、update – 映射更新语句&ensp;&ensp;&ensp;&ensp;8、delete – 映射删除语句&ensp;&ensp;&ensp;&ensp;9、select – 映射查询语句 select元素 在以上几个元素中，select应该是最为常用的，此标签主要用于查询操作，例如： 123&lt;select id="findUserById" resultType="User"&gt; SELECT * FROM USER WHERE ID = #&#123;id&#125;&lt;/select&gt; id值可以自定义，但是为了规范，id值应该填写Mapper接口中对应的方法名，resultType为返回结果的类型。select元素可用的属性如下： 属性 描述 id 在命名空间中唯一的标识符，可用来引用select标签中的SQL语句 databaseid 数据库ID（数据库的版本） fetchSize 设置驱动程序每次批量返回的结果行数 flushCache 清空缓存，默认值为false parameterMap 这是引用外部 parameterMap，已废弃 parameterType 传入SQL语句的参数的完整类名或别名 resultOrdered 默认为false，适用于嵌套结果的Select语句 resultSets 设置多结果集名称 resultSetType 可选值：FORWARD_ONLY、SCROLL_SENSITIVE、SCROLL_INSENSITIVE。默认为不设置，由驱动程序决定 resultType 语句中返回类型的完整类名或别名。如果是集合，则是集合中泛型的类型 resultMap 命名引用外部的 resultMap statementType 可选值：STATEMENT,PREPARED 或 CALLABLE，即： Statement，PreparedStatement 或 CallableStatement，默认为PREPARED timeout 设置超时时间 useCache 默认为true，启用缓存，缓存SQL语句返回的结果 关于其他元素的属性值设置，可查看官方文档 sql元素&lt;sql id=&quot;xx&quot;&gt;标签可以抽取SQL中重复的片段，在需要引用的地方可以使用&lt;include id=&quot;xx&quot;&gt;标签进行引用 动态SQL什么是动态SQL？按我自己的理解就是在SQL映射文件中嵌入标签元素，使用这些标签能够帮助我们定制化SQL语句。 if标签 &lt;if test=&quot;&quot;&gt;&lt;/if&gt;标签：进行参数判断，例如判断参数是否为空null或者为空字符串&lt;where&gt;标签可以去掉第一个前and，即第一个条件判断成立的语句中的前面的第一个and会被去掉 forEachforEach标签的collection属性，如果参数是数组，那么collection属性的值需填写array，如果是集合，那么填写list，如果参数是VO对象中的某个属性，那么直接填写VO对象的类名称即可。 逆向工程 官方文档 GitHub源码下载地址 mybatis中的逆向工程能实际上指的就是代码生成器，它能够帮助我们自动地生成一些低创造性的代码，例如POJO类、Mapper接口、Sql映射文件，这些类和接口都是最为基础性的、但同时又是不可或缺的，例如：数据库中有一百张数据表，那么意味着可能要为这一百张表创建一百个与之对应的POJO类，如果让程序员去做这件事的话，无疑是浪费人力财力，而Mybatis官方也考虑到了这个问题，为了能够提高开发的效率，让开发者更专注于有创造性的工作，Mybatis官方提供逆向工程的解决方案，帮助开发者解决这些简单而又繁琐的问题。 逆向工程的使用在使用逆向工程生成POJO类、Mapper接口以及Sql映射文件时，为了避免影响现有的项目、建议新建一个项目来进行。下面以Oracle数据库中SCOTT用户下的EMP表和DEPT表为例，逆向生成POJO类、Mapper接口、Sql映射文件。 导包 创建generatorConfig.xml文件generatorConfig.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt; &lt;generatorConfiguration&gt; &lt;context id="OracleTables" targetRuntime="MyBatis3"&gt; &lt;!-- 配置数据库连接 --&gt; &lt;jdbcConnection driverClass="oracle.jdbc.driver.OracleDriver" connectionURL="jdbc:oracle:thin:@localhost:1521:mack" userId="scott" password="tiger"&gt; &lt;/jdbcConnection&gt; &lt;!-- 配置Java解析类型 --&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- 配置POJO类的生成位置 --&gt; &lt;javaModelGenerator targetPackage="com.my.mybatis.pojo" targetProject=".\src"&gt; &lt;!-- 是否让schema作为包后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;!-- 取出数据库返回值的前后空格 --&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- mapper映射文件的生成位置 --&gt; &lt;sqlMapGenerator targetPackage="com.my.mybatis.mapper" targetProject=".\src"&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 配置mapper接口的生成位置 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.my.mybatis.mapper" targetProject=".\src"&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定用于逆向的数据表 --&gt; &lt;table schema="" tableName="EMP" domainObjectName="Employee"&gt;&lt;/table&gt; &lt;table schema="" tableName="DEPT" domainObjectName="Department"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 编写工具类核心代码Mybatis官网有提供，详情查看官方文档 SqlMapGenerator.java12345678910111213141516171819202122232425262728293031323334353637383940414243package com.my.util;import java.io.File;import java.io.IOException;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.exception.InvalidConfigurationException;import org.mybatis.generator.exception.XMLParserException;import org.mybatis.generator.internal.DefaultShellCallback;/** * mybatis逆向工程工具类, * @author Mackvord * @date 2018年8月22日 * @version 1.0 */public class SqlMapGenerator &#123; /** * 生成POJO类、Mapper接口、Mapper映射文件 * @throws IOException * @throws XMLParserException * @throws InvalidConfigurationException * @throws SQLException * @throws InterruptedException */ public static void generator() throws IOException, XMLParserException, InvalidConfigurationException, SQLException, InterruptedException &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File("generatorConfig.xml"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125; &#125; 测试测试类123456789101112131415161718192021222324252627282930package com.my.test;import java.io.IOException;import java.sql.SQLException;import org.junit.Test;import org.mybatis.generator.exception.InvalidConfigurationException;import org.mybatis.generator.exception.XMLParserException;import com.my.util.SqlMapGenerator;/** * 测试mybatis逆向工程生成POJO、Mapper接口、Mapper映射文件 * @author Mackvord * @date 2018年8月22日 * @version 1.0 */public class SqlMapGeneratorTest &#123; @Test public void generatorTest() &#123; try &#123; SqlMapGenerator.generator(); &#125; catch (IOException | XMLParserException | InvalidConfigurationException | SQLException | InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 结果：]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>增删改查</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle基础篇]]></title>
    <url>%2Fdatabase%2F4240282551.html</url>
    <content type="text"><![CDATA[基本查询、过滤、排序，多表查询、子查询以及连接Oracle数据库碰到的一些问题的总结 Oracle简介Oracle数据库是由Oracle（甲骨文）公司推出的一款关系型数据库，Oracle公司在关系型数据库领域的地位是不可撼动的，就像Java在后台开发中具有无可比拟的优势一样，现在最为流行的开源数据库MySQL也被Oracle公司收购，成为了Oracle公司旗下的产品。 Oracle的基本操作SQLPlus SQLPlus是Oracle提供的连接数据库的工具，也可以直接使用windows提供的命令行连接数据库，在命令行下使用SQLPlus连接数据库：sqlplus 用户名/密码 格式化命令 在windows命令行下可能会出现数据表显示格式乱的情况，解决的办法是将命令行窗体调大些，如果数据表包含的数据条数比较多，可能会出现表字段重复的问题，此时可以对显示进行格式化，方便阅读，语法如下： 123456查看行宽：SHOW LINESIZE;设置行宽：SET LINESIZE 300;设置列宽：COLUM 列名 FOR 列宽; || 简写方式：COL 列名 FOR 列宽; |- 字符列：COLUM TNAME FORMAT a8;其中a8表示列宽为8个字符 |- 数字列：COLUM TNAME FORMAT 9999;其中9999表示列宽为4为数字设置每页长度：SET PAGESIZE 30; 切换用户 123命令：CONN 用户名/密码 [AS SYSDBA] 注意：如果当前的用户为sys,那么必须写上“AS SYSDBA”[]不用写，否则无法登录命令：show user，显示用户名 HOST指令 在SQLplus中除了可以使用Oracle定义的命令另外，也可以使用HOST指令调用本机的操作系统命令， 例如 123echo命令： HOST echo helloworld清屏命令：HOST CLS文件拷贝命令：copy 源文件路径 目标文件路径，HOST copy 源文件路径 目标文件路径 SQL查询SQL指的是结构化的查询语言，SQL常用的语法：SELECT、FROM、WHERE、GROUP BY、HAVING、ORDER BY、INSERT、UPDATE、DELETE、CREATE、DORP、ALTER、GRANT、REVOKE。SQL分为三种类型： 123DML（数据操作语言，开发中使用的部分）：主要指数据库的查询与更新操作DDL（数据定义语言，开发前设计）：主要指的是数据对象的创建（表、用户）DCL（数据控制语言，系统管理人员）：主要进行权限的管理操作（需要结合用户来观察），此部分由DBA负责 基本查询 12341、查询一个用户下的所有表 |- SELECT * FROM tab;2、查询一个表的结构 |- DESC 表名称; SQL限定查询 123456789101112131415161718192021222324252627282930313233343536373839SELECT [DISTING] * 列名称,别名 列名称,别名 列名称,别名 FORM 表名称 别名WHERE 过滤条件其中过滤条件： 关系运算符：&gt;、&lt;、&gt;=、&lt;=、&lt;&gt;(!=) 逻辑运算符：AND、OR、NOT 范围运算符：BETWEEN...AND 谓词范围：IN、NOTIN 空判断：IS NULL、IS NOT NULL 模糊查询：LIKE、NOT LIKE以SCOTT用户下的EMP表为例1、 查询所有工资大于5000的信息 |=&gt; SELECT * FROM EMP WHEER SAL&gt;5000;2、 查询部门编号为30的雇员姓名、职位以及工资 |=&gt; SELECT ENAME,JOB,SAL FROM EMP WHERE DEPTNO=30;3、 查询工资不等于5000的员工姓名信息 |=&gt; SELECT ENAME,姓名 FORM EMP WHERE SAL&lt;&gt;5000;4、 查询工资在2000到5000之间的员工姓名信息 |=&gt; SELECT ENAEM FROM EMP SAL&gt;2000 AND SAL&lt;5000;5、 查询工资在2000到5000之间的员工姓名信息， |=&gt; SELECT ENAEM FROM EMP BETWEEN 2000 AND 5000; |=&gt; 相比上面的那一句，这一句在性能上有所提升，因为只匹配一个条件6、 日期的写法 |=&gt; SELECT * FROM EMP WHERE HIREDATE BETWEEN &apos;01-1月 -81&apos; AND &apos;31-12月 -81&apos;;7、 查询佣金为空的雇员姓名 |=&gt; SELECT ENAME FROM EMP WHERE COMM IS NULL;8、查询指定雇员编号范围内的所有雇员信息 |=&gt; SELECT * FROM EMP WHERE EMPNO IN (7654,7900,7902,4563); |=&gt; IN 类似于BETWEEN...AND,但是范围较小，有限元素个数 模糊查询 模糊查询事实上也是限定查询的一种，只是限定条件的不同，模糊查询的限定条件为LIKE或者NOT LIKE Example:12345678910111213141、 查询ename中以B开头的所有信息 |=&gt; SELECT * FROM EMP WHERE ENAME LIKE &apos;B%&apos;;2、 查询ename中包含有B的所有信息 |=&gt; SELECT * FROM EMP WHERE ENAME LIKE &apos;%B%&apos;;3、 查询ename中第二个字母为B的所有信息 |=&gt; SELECT * FROM EMP WHERE ENAME LIKE &apos;_B%&apos;;4、 查询ename中为任意字母的所有信息，相当于全部查询，但是不推荐这样进行查询，性能低 |=&gt; SELECT * FROM EMP WHERE ENAME LIKE &apos;%%&apos;;5、 查询姓名中没有‘R’的员工(模糊查询) |=&gt; SELECT ENAME FROM EMP WHERE ENAME NOT LIKE &apos;%R%&apos;; Tips1、WHERE语句一般写在在FROM语句的后面，并且紧随其后执行、SELECT语句控制列的显示数据、WHERE控制着行的显示数据，SELECT语句落后于WHERE执行，SELECT语句可以定义别名，WHERE语句不能定义别名。2、在模糊查询中，如果不设置关键字（%%）、表示全部查询。3、使用NOT IN进行查询的时候，查询范围中不能出现NULL，否则不会有任何查询结果返回。 查询排序排序是根据需求对查询结果进行处理，方便开发人员更好地分析和处理数据。 基本语法123456[2、控制要显示的数据列]SELECT [DISTINCT] * 列名称,别名 列名称,别名 列名称,别名 [1、确定数据来源]FORM 表名称 别名[3、确定数据满足的条件]WHERE 过滤条件[4、针对查询结果进行排序]ORDER BY 字段 [ASC | DESC]，字段[ASC | DESC]...// ASC为升序(从小到大)、DESC为降序（从大到小）、DISTINCT为去除重复，默认为升序 12345678910111、查询部门编号为30的雇员姓名、职位、年薪，并按月薪进行升序 |=&gt; SELECT ENAME,JOB,SAL*12 INCOME FROM EMP WHERE DEPTNO=30 ORDER BY SAL;2、查询部门编号为30的雇员姓名、职位、年薪，并按年薪进行升序（只有ORDER BY子句可以使用SELECT语句的别名） |=&gt; SELECT ENAME,JOB,SAL*12 INCOME FROM EMP WHERE DEPTNO=30 ORDER BY INCOME;3、查询emp表所有信息，按月薪升序 |=&gt; SELECT * FROM EMP ORDER BY SAL ASC;4、查询部门编号为30的雇员编号、雇员姓名、职位、年薪，按月薪升序、雇员编号降序 |=&gt; SELECT EMPNO,ENAME,JOB,SAL*12 INCOME FROM EMP WHERE DEPTNO=30 ORDER BY SAL ASC,EMPNO DESC; 单行函数单行函数格式：返回值 函数名称（参数） 字符串函数 单行函数格式：返回值 函数名称（参数） 函数名称 描述 字符串 UPPER(列 or 字符串) 将传入的字符串或列变为大写 字符串 LOWER(列 or 字符串) 将传入的字符串或列变为小写 字符串 INITCAP(列 or 字符串) 开头首字母大写，其余字母小写 数字 LENGHT(列 or 字符串) 取得指定字符串的长度 字符串 SUBSTR (列 or 字符串，开始索引，长度) 进行字符串的截取，如果没有设置长度，则表示从开始索引一直截取到结尾 字符串 REPLACE(列 or 字符串，旧内容，新内容) 将指定的新数据替换掉旧数据 Example:12341、 查询姓名长度为5的所有员工信息 |=&gt; SELECT * FROM EMP WHERE LENGTH(ENAME)=5;2、 查询员工姓名以及取得员工姓名后三位的信息 |=&gt; SELECT ENAME,SUBSTR(ENAME,LENGTH(ENAME)-2) FROM EMP; 数值函数 数值函数主要是进行数值的处理，核心的函数有三个 函数名称 描述 数字 ROUND(列 or 数字 [,小数位]) 实现数据的四舍五入，可以设置保留的小数位 数字 TRUNC(列 or 数字 [,小数位]) 实现数据的截取，即不进位 数字 MOD(列 or 数字 ,列 or 数字…) 求模 日期函数 要处理日期，有一个前提就是必须要知道当前的日期，Oracle提供了一个专门的伪劣“SYSDTAE”，不包含时分秒，(SYSTIMESTAMP，时间戳，包含时分秒)伪劣：可以作为列来使用，但又不是真正的列。 日期操作公式： 日期 + 数字 = 日期（表示若干天之后的日期） 日期 - 数字 = 日期（表示若干天之前的日期） 日期 - 日期 = 数字（天数） 函数名称 描述 ADD_MONTHS(列 or 日期，月数) 表示在指定的日期增加若干个月之后日期 数字 MONTHS_BETWEEN(列 or 日期，列 or 日期) 返回两个日期之间所经过的月数 日期 LAST_DAY(列 or 日期) 取得指定日期所在月的最后一天 日期 NEXT_DAY(列 or 日期，星期X) 返回下一个一周时间数对应的日期 123计算年份，有两种方法： 方法一：（日期 - 日期）/ 12 = 年 这种方法无法处理闰年的问题 方法二：MONTHS_BETWEEN(SYSDATE,HIREDATE) / 12 = 年 举个栗子：以年、月、日的方式计算出每个雇员的到现在为止的雇佣年限。 12计算年份：ROUND(MONTHS_BETWEEN(SYSDATE,HIREDATE)/12)YEAR计算月份：ROUND(MOD(MONTHS_BETWEEN(SYSDATE,HIREDATE),12))MONTH 年份和月份的计算相对来说比较简单，但天数的计算比较麻烦，在Oracle之中计算天数的方法只有一种，就是日期1 - 日期2，日期1很容就知道是SYSDATE，但是日期2是多少？由于时间跨度比较大，并且每个月的日期不是固定的，所以要想精确计算天数，必须保证(日期1 - 日期2) &lt;= 30 ，所以计算天数的完整语句因该是： 1ROUND(SYSDATE - ADD_MONTHS(HIREDATE,MONTHS_BETWEEN(SYSDATE,HIREDATE)))DAY， 注：进行四舍五入是因为有时分秒 转换函数 转换函数主要是进行三类数据的相互转换操作，数字型、字符串型、日期型，转换函数如下： 函数名称 描述 字符串 TO_CHAR(列 or 数字，转换格式) 将日期或者数字转换为指定结构的字符串 日期 TO_DATE(列 or 字符串，转换格式) 将日期型的字符串转换为日期型数据 数字 TO_NUMBER(列 or 字符串) 将字符串变为数字 TO_CHAR()函数的转换格式：123日期：年（yyyy）、月（mm）、日（dd）时间：时（hh、hh24）、分（mi）、秒（ss）;数字：任意数字（9）、本地货币符号（L） 举个栗子：格式化数字1SELECT TO_CHAR(36374578888,&apos;L999,999,999,999&apos;) FROM DUAL; 多表查询多表查询的形式1234[2、控制要显示的数据列]SELECT [DISTINCT] * 列名称,别名 列名称,别名 列名称,别名... [1、确定数据来源]FORM 表名称 别名,表 别名...[3、确定数据满足的条件]WHERE 过滤条件[4、针对查询结果进行排序]ORDER BY 字段 [ASC | DESC]，字段[ASC | DESC]... 表连接内连接 内连接也叫等值连接，所有满足条件的数据都会被显示出来，如果条件不满足，则无法显示。例如： 1SELECT e.ename,e.job,d.deptno,d.loc FROM EMP e,DEPT d WHERE e.deptno = d.deptno; 外连接 外连接相比等值连接，可以查询左表或者右表中所有的数据，无论条件是否满足。外连接分为左外连接和右外连接。左外连接：返回左表中所有的数据，即使在右表中没有匹配的行。右外连接：返回右表中所有的数据，即使左表中没有匹配的行。 Oracle语法12左外连接： 字段 = 字段（+）右外连接： 字段（+）= 字段 SQL语法（通用）12345678910// 左外连接SELECT column_name...FROM table1LEFT [OUTER] JOIN table2ON table1.column_name=table2.column_name// 右外连接SELECT column_name...FROM table1RIGHT [OUTER] JOIN table2ON table1.column_name=table2.column_name 例如： 12SELECT e.ename,e.job,m.ename mgr FROM emp e,emp m WHERE e.mgr = m.empno(+);SELECT e.ename,e.job,m.ename mgr FROM emp e LEFT JOIN emp m ON e.mgr = m.empno; 笛卡尔积笛卡尔积是数学上的一个公式，即两个集合的乘积，数据库的多表操作也是基于这个公式，但是在实际情况下，不同的数据表有可能存在相同的字段，这就导致了在最原始的多表查询的操作中出现了错误数据的情况，例如：EMP,DEPT两张表，两张表存在关联字段deptno，当我们执行查询操作：select * from emp,dept;的时候，会发现得到的结果是两张表记录的乘积： 查询得到56条数据，其中就出现了一些错误的数据 所以为了避免出现这种问题，应该加上一个where条件，例如select * from A a,B b where a.deptno = b.deptno;，加上限制条件之后，就能过滤掉一些不应该出现的错误的数据： tips上面的查询语句并不能消除笛卡尔积，只是在显示上消除了笛卡尔积的问题，多表查询的性能是非常差的，在开发中尽可能避免使用多表查询。 子查询所谓子查询就是在一个查询语句中嵌套其他的查询语句。在SQL99（SQL1999）标准中，子查询可以在任意位置插入，例如：SELECT子句、WHERE子句、FROM子句… 举个栗子：查询每个部门的编号、名称以及部门的人数 问题拆分： 涉及到的数据表：部门表（部门编号、名称）、员工表（部门人数） 限定的查询条件：EMP.deptno = DEPT.deptno 查询方式一：多表查询1234SELECT d.deptno,d.dname,count(e.empno) countFROM emp e RIGHT JOIN dept dON e.deptno = d.deptnoGROUP BY d.deptno,d.dname; 查询结果： 查询方式二：子查询123SELECT d.deptno,d.dname,temp.countFROM dept d LEFT JOIN (SELECT deptno,COUNT(empno) count FROM emp e GROUP BY deptno) tempON d.deptno = temp.deptno; 查询结果： 可以发现两种查询得到的结果是一样的，但是实际上子查询的性能要比多表查询的性能要好，我们可以假设部门表中有100条记录，员工表中有10000条记录，那么多表查询操作的记录数就是100*10000条，而在子查询中temp表的记录数实际上最多是100条，因为子查询中按照部门编号进行了分组，那么也就意味着子查询操作的记录数实际上是100*100条，显然子查询的性能要比多表查询的性能要好。 tips子查询的结果如果存在null值，那么在使用NOT IN操作的时候不会有任何结果返回。 原生连接Oracle数据库操作步骤 在操作之前我已经在自己的电脑上安装了Oracle数据库，这里以SOCTT用户为例，使用java.sql包下的DriverManager类来获取数据库连接，关于JDBC连接数据库的操作几乎都是固定的，步骤如下： 12341、加载数据库驱动程序（向容器加载）；2、进行数据库连接（通过DriverManager类完成）3、进行数据的CRUD（增删改查）[Statement、ResultSet、PrepareStatement]4、关闭连接 连接形式 12数据库的连接地址：jdbc:oracle:连接方式:主机名称:端口名称:数据库的SID例如：jdbc:oracle:thin:@localhost:1521:mack 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.my.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;/** * 原生连接Oracle数据库 * @author Mackvord * @date 2018年8月21日 * @version 1.0 */public class OracleConnection &#123; /** * 声明数据库驱动 */ private static final String DRIVERCLASS = "oracle.jdbc.driver.OracleDriver"; /** * 声明数据库连接地址 */ private static final String URL = "jdbc:oracle:thin:@localhost:1521:mack"; /** * 声明连接用户 */ private static final String USERNAME = "scott"; /** * 声明连接密码 */ private static final String PASSWORD = "tiger"; /** * 获取数据库连接的方法 * @throws ClassNotFoundException * @throws SQLException */ public static Connection getConnection() throws ClassNotFoundException, SQLException &#123; // 加载数据库驱动 Class.forName(DRIVERCLASS); // 获取数据库连接并返回 return DriverManager.getConnection(URL, USERNAME, PASSWORD); &#125; public static void main(String[] args) &#123; try &#123; Connection connection = OracleConnection.getConnection(); Statement statement = connection.createStatement(); String sql = "SELECT JOB FROM EMP WHERE ENAME = 'KING'"; ResultSet rs = statement.executeQuery(sql); if (rs.next()) &#123; System.out.println(rs.getString(1)); &#125; connection.close(); &#125; catch (ClassNotFoundException | SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 关于连不上Oracle数据库的一些原因及解决办法如果发现连不上数据库，先检查数据库相关的服务是否启动，再排查其他的问题： 1、监听服务出错 检查监听的主机名称是不是本地的计算机名称 监听配置文件路径：~/product/11.2.0/dbhome_1/NETWORK/ADMIN/ listener.ora tnsnames.ora 2、找不到指定的SID 数据库的名字就是SID的名称，但是很多时候会发现该名字不会被自动注册，就是说只有数据库名称没有对应的SID名称，此时可以打开数据库的网络- 管理工具（Net Manager），重新添加数据库并保存网络配置，那么此时就会自动在listener.ora文件中注册一个SID]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>查询</tag>
        <tag>过滤</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN]]></title>
    <url>%2Freversion-control%2F3963543486.html</url>
    <content type="text"><![CDATA[版本管理工具–Subversion SVN简介SVN(Subversion的缩写)，是一个开源的版本控制系统，代码协同开发管理工具。 Eclipse安装Subversion插件安装插件非常简单，但是有一个注意的地方就是在安装插件的时候尽量选择Install New Software进行安装，选择Eclipse Martetplace安装有时候会出现一些莫名其妙的错误。安装过程截图： 链接地址: https://dl.bintray.com/subclipse/releases/subclipse/latest/]]></content>
      <categories>
        <category>reversion_control</category>
      </categories>
      <tags>
        <tag>版本控制</tag>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH Exception]]></title>
    <url>%2Fexception%2F3359012571.html</url>
    <content type="text"><![CDATA[关于Struts2、Spring、Hibernate三大框架整合中碰到的异常 没有匹配名称空间[/]的Action异常信息： 这个异常应该很多开发者都遇到过，出现这个异常的原因有很多种，我自己也尝试着结合自己遇到的问题以及前人的经验总结了一下可能会造成这个问题的因素： 解决思路 1解决思路 2解决思路 3解决思路 4检查struts.xml配置文件，包括文件的名称是否写错、文件路径（src）是否正确，文件的配置是否正确 检查web.xml文件，包括默认的欢迎页面的配置、struts过滤器的配置 检查动态方法调用的配置 检查struts约束文件版本 按照以上思路逐一排查，首先想到的肯定是struts.xml文件，文件名正确，路径也没问题，之后检查配置似乎也没有问题，完了之后检查web.xml文件，过滤器的配置以及默认首页的配置都没问题，郁闷了两分钟！完事之后想了下，我在struts.xml配置了使用通配符访问Action中方法，即： 123&lt;action name="UserAction_*" class="com.my.web.action.UserAction" method="&#123;1&#125;"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt;&lt;/action&gt; 会不会是这里出现问题？之后在struts.xml中开启了动态方法调用，即 1struts.enable.DynamicMethodInvocation = true 这一配置默认情况下是false，启用后我以为能解决问题，是事实然并卵，又郁闷了两分钟！最后发现网上有人也遇到了这种问题，说有可能是约束文件的版本问题，2.3之后的约束在使用通配符方法Action中的方法的时候，还需要额外配置一个选项&lt;allowed-methods&gt;，在此元素中配置允许通过通配符进行访问的方法，即： 1&lt;allowed-methods&gt;方法名1,方法名2...&lt;/allowed-methods&gt; 检查我自己的约束文件发现，我使用的2.5版本的约束，配置了allowed-methods之后，发现可以正常访问了。 空指向异常123456789101112131415161718java.lang.NullPointerException at com.my.web.action.CustomerAction.list(CustomerAction.java:42) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) at java.lang.reflect.Method.invoke(Unknown Source) at ognl.OgnlRuntime.invokeMethod(OgnlRuntime.java:899) at ognl.OgnlRuntime.callAppropriateMethod(OgnlRuntime.java:1544) at ognl.ObjectMethodAccessor.callMethod(ObjectMethodAccessor.java:68) at com.opensymphony.xwork2.ognl.accessor.XWorkMethodAccessor.callMethodWithDebugInfo(XWorkMethodAccessor.java:98) at com.opensymphony.xwork2.ognl.accessor.XWorkMethodAccessor.callMethod(XWorkMethodAccessor.java:90) at ognl.OgnlRuntime.callMethod(OgnlRuntime.java:1620) at ognl.ASTMethod.getValueBody(ASTMethod.java:91) at ognl.SimpleNode.evaluateGetValueBody(SimpleNode.java:212) at ognl.SimpleNode.getValue(SimpleNode.java:258) at ognl.Ognl.getValue(Ognl.java:470) at ognl.Ognl.getValue(Ognl.java:434) at com.opensymphony.xwork2.ognl.OgnlUtil$3.execute(OgnlUtil.java:374) 在Spring与中Struts2整合之后，如果Action的生命周期完全由Spring来管理，并且Action中存在有依赖属性，那么在struts.xml中配置Action时，class属性的值必须与Spring的配置文件applicationContext.xml中bean元素的name属性的值一致，否则将报空指针。比如，我在struts.xml配置了一个action： struts.xml 错误的配置12345678910&lt;package name="crm" namespace="/" extends="struts-default"&gt; &lt;!-- 将Action对象的创建交给spring容器来处理 --&gt; &lt;constant name="struts.objectFactory" value="spring"&gt;&lt;/constant&gt; &lt;!-- 此处的class属性的值必须与Spring的配置文件`applicationContext.xml`中`bean`元素的`name`属性的值一致 --&gt; &lt;action name="CustomerAction_*" class="com.my.web.action.CustomerAction" method="&#123;1&#125;"&gt; &lt;result name="list"&gt;/jsp/customer/list.jsp&lt;/result&gt; &lt;result name="error"&gt;/error.jsp&lt;/result&gt; &lt;allowed-methods&gt;list&lt;/allowed-methods&gt; &lt;/action&gt;&lt;/package&gt; applicationContext.xml123&lt;bean name="customerAction" class="com.my.web.action.CustomerAction" scope="prototype"&gt; &lt;property name="cs" ref="customerService"&gt;&lt;/property&gt;&lt;/bean&gt; 这里出现空指针表上面是因为action中class属性值与bean中name属性值不一致，实质上是因为在Action中声明了Service层的对象，因为如果在Action中没有声明Service层的对象，没有产生依赖，那么在struts.xml中的action元素的class属性是可以通过完整类名来配置的，这样的话Action就会由Struts2负责创建而不是由Spring来创建。 struts.xml 正确的配置12345678910&lt;package name="crm" namespace="/" extends="struts-default"&gt; &lt;!-- 将Action对象的创建交给spring容器来处理 --&gt; &lt;constant name="struts.objectFactory" value="spring"&gt;&lt;/constant&gt; &lt;!-- 此处的class属性的值必须与Spring的配置文件`applicationContext.xml`中`bean`元素的`name`属性的值一致 --&gt; &lt;action name="CustomerAction_*" class="customerAction" method="&#123;1&#125;"&gt; &lt;result name="list"&gt;/jsp/customer/list.jsp&lt;/result&gt; &lt;result name="error"&gt;/error.jsp&lt;/result&gt; &lt;allowed-methods&gt;list&lt;/allowed-methods&gt; &lt;/action&gt;&lt;/package&gt;]]></content>
      <categories>
        <category>exception</category>
      </categories>
      <tags>
        <tag>404</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-Framework]]></title>
    <url>%2Fspring%2F1924138728.html</url>
    <content type="text"><![CDATA[Spring-Framework 搭建、基础操作 Spring简介 Spring官网Spring是一个开源框架，或者说是一个轻量级的容器，为解决企业应用程序开发的复杂性而生。Spring可以针对Bean的生命周期进行管理并且具有良好的分层架构，其核心为IOC(反转控制)，采用了AOP(面向切面编程)思想，同时也提供与其他流行的Web应用框架的整合方案，包括Struts2、Hibernate、Mybatis等。 Spring架构 Spring框架搭建导包 导入约束 创建类 定义接口123public interface HelloDao &#123; void hello();&#125; 接口实现类123456public class HelloDaoImpl implements HelloDao &#123; @Override public void hello()&#123; System.out.println("Hello Spring !"); &#125;&#125; 设置配置文件 applicationContext.xml12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd "&gt; &lt;bean name="hello" class="com.my.dao.HelloDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; IOC与DIIOC (Inversion of Control的缩写)，即控制反转；DI (Dependency Injection的缩写)，即依赖注入。IOC与DI是面向对象编程中的一种设计原则，其作用就是降低代码之间的耦合度，即各个模块之间的关联度。在Java中，代码耦合的根本原因就是使用new 调用构造方法创建对象，如果各个模块之间都使用new的方式来创建其所依赖的对象，将会导致不同模块之间的代码耦合度变高，这就意味着代码的维护和调试成本将被提高。而IOC正是为此而生，所谓控制反转，即由原来各个模块自己创建对象反转为将对象的创建交个一个容器(可以将其理解为一个第三方的机构)帮助我们进行创建和管理，各模块所依赖的对象只需要对容器中创建的对象进行引用即可。依赖注入正是将引用注入到依赖对象中，这样依赖的对象就与容器中的对象产生了关联，最终达到松耦合的目的。Spring框架在设计上也采用了这种设计原则，因此Spring能够很好地帮助我们管理对象以及对象之间的依赖关系。 Spring注解Spring@Component(“user”)相当于@Service：Service层注解@Controller：Web层注解@Repository：Dao层注解@Scope(scopeName=”singleton”)@Value(“Alibaba”)@PostConstruct@PreDestroy Spring与Junit整合测试1234567891011121314151617181920212223242526package com.my.junit;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.my.bean.User;// 使用注解创建Spring容器@RunWith(SpringJUnit4ClassRunner.class)// 指定创建容器使用哪个配置文件@ContextConfiguration("classpath:applicationContext.xml")public class JunitDemo &#123; // 将名为user的对象注入到user变量中 @Resource(name="user") private User user; @Test public void fun() &#123; System.out.println("This is a test !" + user); &#125;&#125; AOP思想AOP（Aspect Oriented Programming）即面向切面编程，其主要的作用就是分离程序的业务逻辑与系统级服务（日志、权限认证、事务管理等）。过滤器、拦截器、动态代理都蕴含了AOP思想。 Spring AOP名词 切面(Aspect): 一个关注点的模块化切入点(Pointcut): 匹配连接点的断言。连接点(Joinpoint): 程序在执行过程中某个特定的点通知(Advice): 在切面的某个特定的连接点上执行的动作目标对象(Target Object): 被一个或者多个切面所通知的对象织入(Weaving): 把切面连接到其他的应用程序类型或者对象上，并创建一个被通知的对象引入(Introduction) 在不修改类代码的前提下，为类添加新的方法和属性 通知(Advice)的类型 通知类型 描述 前置通知(Before Advice) 在连接点之前执行的通知，但不能阻止连接点前的执行 后置通知(After Returning Advice) 在连接点正常执行完后执行的通知 后置通知(After finally Advice) 当连接点退出的时候执行的通知（无论是否出现异常） 环绕通知(Around Advice) 连接点之前和之后都会执行的通知 异常通知(After Throwing Advice) 在方法抛出异常退出时执行的通知 Spring JdbcSpring Jdbc操作数据库 Spring中整合了Jdbc对数据库操作，在JdbcTemplate类中提供一系列操作数据库的方法，使用JdbcTemplate类对象操作数据库有点类似于QueryRunner，那么如何去使用JdbcTemplate类操作数据库？方法一：在DAO层接口的实现类中声明一个JdbcTemplate对象，并且提供set方法，然后在配置文件对此对象进行注入，并且在配置文件中配置DataSource，因为JdbcTemplate需要通过连接池连接数据库，除此之外还需要将DAO层接口的实现类配置到spring中，那么在需要进行数据库操作的时候，只需要声明一个xxxDao接口对象，将spring配置文件中的配置的xxxDao注入到声明的对象中即可，具体的配置如下： applicationContext.xml1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd "&gt; &lt;!-- 配置思路：Dao依赖于jdbcTemplate,jdbcTemplate依赖于DataSource --&gt; &lt;!-- 1.将连接池配置到spring容器中 --&gt; &lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!-- 使用set方式向DataSource中注入属性 --&gt; &lt;property name="driverClass" value="com.mysql.cj.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///spring?useSSL=false&amp;amp;serverTimezone=GMT%2B8"&gt;&lt;/property&gt; &lt;property name="user" value="mackvord"&gt;&lt;/property&gt; &lt;property name="password" value="12345678"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 将Jdbctemplate配置到spring容器中--&gt; &lt;bean name="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 将xxxDao配置到spring容器中 --&gt; &lt;bean name="xxxDao" class="com.my.jdbctemplate.xxxrDaoImpl"&gt; &lt;property name="jt" ref="jdbcTemplate"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 第二种方法是直接继承JdbcDaoSupport类，JdbcDaoSupport类会根据DataSource自动创建JdbcTemplate类实例，也就是说我们不用再在DAO层手动声明一个JdbcTemplate对象并进行注入，相比上面的方法，这种方法不用再将JdbcTemplate配置spring容器中，而是直接在xxxDaobean中引用dataSource即可 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd "&gt; &lt;!-- 1.将连接池交给spring容器管理 --&gt; &lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!-- 使用set方式向DataSource中注入属性 --&gt; &lt;property name="driverClass" value="com.mysql.cj.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///spring?useSSL=false&amp;amp;serverTimezone=GMT%2B8"&gt;&lt;/property&gt; &lt;property name="user" value="mackvord"&gt;&lt;/property&gt; &lt;property name="password" value="12345678"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 将Jdbctemplate交给spring容器管理 --&gt; &lt;!-- &lt;bean name="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- 将UserDao交给spring容器管理 --&gt; &lt;bean name="xxxDao" class="com.my.jdbctemplate.xxxDaoImpl"&gt; &lt;!-- &lt;property name="jt" ref="jdbcTemplate"&gt;&lt;/property&gt; --&gt; &lt;!-- 如果Dao继承了JdbcDaoSupport类，那么就无需再手动配置jdbctemplate，只需要将DataSource注入到daobean中即可 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 关于配置dataSource，即配置数据库的驱动、连接地址、用户和密码。还有另外一种方式，不是直接在spring中配置，而是将这些信息配置到资源文件中，spring直接从资源文件中读取。 applicationContext.xml12345678&lt;!-- 指定spring读取properties中的配置 --&gt;&lt;context:property-placeholder location="classpath:db.properties" /&gt;&lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt;&lt;/bean&gt; db.properties1234jdbc.driverClass=com.mysql.cj.jdbc.Driverjdbc.jdbcUrl=jdbc:mysql:///spring?useSSL=false&amp;serverTimezone=GMT%2B8jdbc.user=mackvordjdbc.password=12345678 Tips在xml文件中配置数据库连接地址的时候，后面的参数之间使用&amp;amp;连接，而在properties文件中&amp;符号连接，两者本质上是一样的，前者是转义字符。 Spring事务管理我们知道，对于不同的数据库平台，其操作的代码的是不一样的，为了解决这个问题，Spring提供一个可针对不同平台进行不同处理的接口PlatformTransactionManager,并且封装了此接口的不同实现，包括JDBCTransactionManager，HibernateTransactionManager，MybatisTransactionManager。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>Spring-Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2]]></title>
    <url>%2Fstruts2%2F1596734395.html</url>
    <content type="text"><![CDATA[Struts2框架搭建、OGNL表达式、配置过滤器、获取参数 Struts2简介 Struts2官网 Struts2教程Struts2 是目前较为普及和成熟的基于MVC设计模式的web应用程序框架，其优雅、简洁、可扩展的特点使得其备受开发者的青睐，并且结合了WebWork和Struts的框架的优点，因此在一定程度上简化了WEB层的开发。 Struts2架构图 Struts2框架的搭建在深入学习Struts2框架之前我们需要先把Struts2框架给搭起来，下面我就来演示如何搭建Struts2框架并创建一个Hello World示例。 1、下载Struts2压缩包2、创建动态Web项目3、导包、配置dtd文件4、创建Action类5、创建JSP页面6、设置配置文件7、配置Struts2核心过滤器8、测试 1、下载Struts2压缩包 压缩包直接到官网下载即可，版本可以根据自己的需要选择，我下载的是struts-2.5.16-all.zip 2、创建动态Web项目 在Eclipse中创建动态的Web项目，服务器我选择的是Tomcat 9: 3、导包、配置的dtd文件 导包可以根据自己的需要进行，Struts2提供的jar包一共有90个，这里由于仅仅是演示一个Hello World的例子，只选择一些必须用到的jar包，如果实在不知道如何选择，可以从Struts2提供的apps示例中选取jar包。 设置dtd约束文件： 4、创建Action类 Action类是Struts2 应用程序的关键,类似Servlet，通常情况下，在Action类中包含了完整的业务逻辑并控制用户、模型以及视图间的交互。在Java Resources =&gt; src下创建一个HelloWorldAction，在HelloWorldAction类中继承ActionSupport类并重写execute()方法。 HelloWorldAction.java1234567891011121314package com.my.struts2.hello;import com.opensymphony.xwork2.ActionSupport;@SuppressWarnings("serial")public class HelloAction extends ActionSupport &#123; @Override public String execute() &#123; System.out.println("hello world !"); return "success"; &#125; &#125; 5、创建JSP页面 新建一个JSP页面，在执行Action后转发到此页面： Hello.jsp123456789101112&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello World ！！！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 6、设置配置文件 在项目的src路径下新建一个struts.xml文件，配置如下： struts.xml1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;package name="hello" namespace="/hello" extends="struts-default"&gt; &lt;action name="HelloAction" class="com.my.hello.HelloAction" method="execute"&gt; &lt;result name="success"&gt;/hello.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 7、配置Struts2核心过滤器 在web.xml中配置Struts2核心过滤器: web.xml1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;Struts2-Hello&lt;/display-name&gt; &lt;!-- 配置Struts2核心过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 8、测试 将Web项目部署到Tomcat上，在浏览器中访问：http://localhost:8080/Struts2-Hello/hello/HelloAction.action，成功输出Hello World ！ OGNL表达式OGNL即Object-Graph Navigation Language的缩写，是一种功能强大的表达式语言，使用OGNL表达式可以轻松地存取任意对象的属性、调用普通方法、访问静态属性，使用OGNL表达式所需的jar包在Struts2框架中就有，因此无需额外导包 使用OGNL存取对象的属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.my.ognl;import java.util.HashMap;import java.util.Map;import org.junit.Test;import com.my.bean.User;import ognl.Ognl;import ognl.OgnlContext;import ognl.OgnlException;public class OgnlDemo &#123; /** * OGNL基本语法，设置值、取出值、调用方法、访问静态属性 * * @throws OgnlException */ @Test public void fun1() throws OgnlException &#123; // 准备OGNLContext // 1.准备Root User rootUser = new User("Jack",18); // 2.准备Context Map&lt;String, User&gt; context = new HashMap&lt;String, User&gt;(); context.put("user1", new User("Jerry", 19)); context.put("user2", new User("Tom", 19)); // 将Root与context添加到OGNL中 OgnlContext oc = new OgnlContext(); oc.setRoot(rootUser); oc.setValues(context); // 编写OGNL语句 // Ognl.getValue("", context, oc.getRoot()); // 1.取出root中user的name String name = (String) Ognl.getValue("name", context, oc.getRoot()); System.out.println(name); // 2.取出context中的user1的name和age，其中#号代表从context中取值 String name1 = (String) Ognl.getValue("#user1.name", context, oc.getRoot()); Integer age1 = (Integer) Ognl.getValue("#user1.age", context, oc.getRoot()); System.out.println(name1); System.out.println(age1); // 3.设置属性值 String name3 = (String) Ognl.getValue("#user1.name='Alice'", context, oc.getRoot()); Integer age3 = (Integer) Ognl.getValue("#user1.age=22", context, oc.getRoot()); System.out.println(name3); System.out.println(age3); // 4.调用普通方法 String name4 = (String) Ognl.getValue("getName()", context, oc.getRoot()); System.out.println(name4); String name5 = (String) Ognl.getValue("#user1.getName()", context, oc.getRoot()); System.out.println(name5); // 5.调用静态方法,语法格式：@完整类名称@静态方法名 String message = (String) Ognl.getValue("@com.my.utils.OgnlUtils@test('Hello OGNL !')", context, oc.getRoot()); System.out.println(message); // 5.1调用内置的Math的静态静态属性 Double pi = (Double) Ognl.getValue("@java.lang.Math@PI", context, oc.getRoot()); // 由于Math是内置的，因此可以直接使用@@静态属性 //Double pi = (Double) Ognl.getValue("@@PI", context, oc.getRoot()); System.out.println(pi); &#125; /** * 创建对象：list、Map * * @throws OgnlException */ @Test public void fun2() throws OgnlException &#123; // 准备OGNLContext // 1.准备Root User rootUser = new User("Jack",18); // 2.准备Context Map&lt;String, User&gt; context = new HashMap&lt;String, User&gt;(); context.put("user1", new User("Jerry", 19)); context.put("user2", new User("Tom", 19)); // 将Root与context添加到OGNL中 OgnlContext oc = new OgnlContext(); oc.setRoot(rootUser); oc.setValues(context); // 编写OGNL语句 // 1.创建list对象并获取其长度 Integer size = (Integer) Ognl.getValue("#&#123;'Alice','Bob','Jerry'&#125;.size()", context, oc.getRoot()); System.out.println(size); // 2.创建Map集合并获取其长度、属性值 Integer size2 = (Integer) Ognl.getValue("#&#123;'name':'Alice','age':18&#125;.size()", context, oc.getRoot()); // 获取属性值1 String name1 = (String) Ognl.getValue("#&#123;'name':'Alice','age':18&#125;['name']", context, oc.getRoot()); // 获取属性值2 Integer age1 = (Integer) Ognl.getValue("#&#123;'name':'Alice','age':18&#125;.get('age')", context, oc.getRoot()); System.out.println(size2); System.out.println("name:" + name1 + " age:" + age1); &#125;&#125; 使用OGNL表达式动态设置参数 123456789101112131415161718192021222324252627282930package com.my.ognl;import com.opensymphony.xwork2.ActionSupport;/** * 测试在配置文件中使用OGNL表达式设置重定向参数 * * @author mackvord * @date 2018年8月3日 * @version 1.0 */public class OgnlDemoAction extends ActionSupport &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String execute() throws Exception &#123; this.name = "Alice"; return SUCCESS; &#125; &#125; 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;constant name="struts.devMode" value="true"&gt;&lt;/constant&gt; &lt;package name="ognl" namespace="/" extends="struts-default"&gt; &lt;action name="PushStackDemoAction" class="com.my.ognl.PushStackDemoAction" method="execute"&gt; &lt;result name="success" type="dispatcher"&gt;/form.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="OgnlDemoAction" class="com.my.ognl.OgnlDemoAction" method="execute"&gt; &lt;result name="success" type="redirectAction"&gt; &lt;param name="namespace"&gt;/&lt;/param&gt; &lt;param name="actionName"&gt;PushStackDemoAction&lt;/param&gt; &lt;!-- 使用ognl表达式动态设置参数，参数会附加在重定向的Action后面 --&gt; &lt;param name="name"&gt;$&#123;name&#125;&lt;/param&gt; &lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; Struts2获取参数首先明确一点：获取参数的方法分为两个步骤：1、获取当前Action的值栈对象；2、将用于封装参数的对象压入值栈中。但是，将参数封装（设置）到对象中的这一过程实际上是由拦截器完成的，那么问题来了，拦截器是在Action之前执行的，也就是说我们必须保证在拦截器执行之前将用于封装参数的对象压入值栈中，这样才能确保拦截器能够将前端提交过来的参数被封装到对象中，那么我们怎么在拦截器执行之前将封装参数的对象压入值栈中？，Struts2为我们提供了两种方法： 1、实现Preparable接口中的prepare()方法 通过查看Struts-default.xml可以发现，Struts2中提供了20默认的个拦截器，在这20个默认的拦截器中有一个prepare拦截器，翻译过来就是准备的意思，也就是说我们可以在这个拦截器中做一些预处理操作，查看此拦截器的源码发现，如果我们想要进行一些预处理操作可以实现Preparable接口，其源码如下（注释部分我已经删掉了）： com.opensymphony.xwork2.interceptor.PrepareInterceptor1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.opensymphony.xwork2.interceptor;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.Preparable;import com.opensymphony.xwork2.util.logging.Logger;import com.opensymphony.xwork2.util.logging.LoggerFactory;import java.lang.reflect.InvocationTargetException;public class PrepareInterceptor extends MethodFilterInterceptor &#123; private static final long serialVersionUID = -5216969014510719786L; private final static String PREPARE_PREFIX = "prepare"; private final static String ALT_PREPARE_PREFIX = "prepareDo"; private boolean alwaysInvokePrepare = true; private boolean firstCallPrepareDo = false; public void setAlwaysInvokePrepare(String alwaysInvokePrepare) &#123; this.alwaysInvokePrepare = Boolean.parseBoolean(alwaysInvokePrepare); &#125; public void setFirstCallPrepareDo(String firstCallPrepareDo) &#123; this.firstCallPrepareDo = Boolean.parseBoolean(firstCallPrepareDo); &#125; @Override public String doIntercept(ActionInvocation invocation) throws Exception &#123; Object action = invocation.getAction(); if (action instanceof Preparable) &#123; try &#123; String[] prefixes; if (firstCallPrepareDo) &#123; prefixes = new String[] &#123;ALT_PREPARE_PREFIX, PREPARE_PREFIX&#125;; &#125; else &#123; prefixes = new String[] &#123;PREPARE_PREFIX, ALT_PREPARE_PREFIX&#125;; &#125; PrefixMethodInvocationUtil.invokePrefixMethod(invocation, prefixes); &#125; catch (InvocationTargetException e) &#123; Throwable cause = e.getCause(); if (cause instanceof Exception) &#123; throw (Exception) cause; &#125; else if(cause instanceof Error) &#123; throw (Error) cause; &#125; else &#123; throw e; &#125; &#125; if (alwaysInvokePrepare) &#123; // 调用prepare()，这就是我们要实现的方法 ((Preparable) action).prepare(); &#125; &#125; return invocation.invoke(); &#125;&#125; struts-default.xml默认拦截器1234567891011121314151617181920212223242526&lt;interceptor-stack name="defaultStack"&gt; &lt;interceptor-ref name="exception"/&gt; &lt;interceptor-ref name="alias"/&gt; &lt;interceptor-ref name="servletConfig"/&gt; &lt;interceptor-ref name="i18n"/&gt; &lt;interceptor-ref name="prepare"/&gt; &lt;interceptor-ref name="chain"/&gt; &lt;interceptor-ref name="scopedModelDriven"/&gt; &lt;interceptor-ref name="modelDriven"/&gt; &lt;interceptor-ref name="fileUpload"/&gt; &lt;interceptor-ref name="checkbox"/&gt; &lt;interceptor-ref name="datetime"/&gt; &lt;interceptor-ref name="multiselect"/&gt; &lt;interceptor-ref name="staticParams"/&gt; &lt;interceptor-ref name="actionMappingParams"/&gt; &lt;interceptor-ref name="params"/&gt; &lt;interceptor-ref name="conversionError"/&gt; &lt;interceptor-ref name="validation"&gt; &lt;param name="excludeMethods"&gt;input,back,cancel,browse&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name="workflow"&gt; &lt;param name="excludeMethods"&gt;input,back,cancel,browse&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name="debugging"/&gt; &lt;interceptor-ref name="deprecation"/&gt;&lt;/interceptor-stack&gt; 压栈的操作可以在prepare()方法中进行，如： prepare()方法1234567@Override public void prepare() throws Exception &#123; // 1.获取值栈 ValueStack valueStack = ActionContext.getContext().getValueStack(); // 2.将对象压入栈中 valueStack.push(user); &#125; 2、实现ModelDriven接口这种方法与实现Preparable接口相比更加简单，我们可以看一下其源码，如果我们在Action中继承了ModelDriven接口，那么我们只需要重写getModel()方法，并将用于封装参数的对象返回即可，压栈的操作将由modelDriven拦截器帮我们进行，从某种程度上来说，这简化了我们的编码操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.opensymphony.xwork2.interceptor;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.ModelDriven;import com.opensymphony.xwork2.util.CompoundRoot;import com.opensymphony.xwork2.util.ValueStack;public class ModelDrivenInterceptor extends AbstractInterceptor &#123; protected boolean refreshModelBeforeResult = false; public void setRefreshModelBeforeResult(boolean val) &#123; this.refreshModelBeforeResult = val; &#125; @Override public String intercept(ActionInvocation invocation) throws Exception &#123; Object action = invocation.getAction(); // 判断action是否是ModelDriven接口的实例 if (action instanceof ModelDriven) &#123; ModelDriven modelDriven = (ModelDriven) action; ValueStack stack = invocation.getStack(); Object model = modelDriven.getModel(); if (model != null) &#123; // 这是最关键的一步，帮我们进行了压栈操作 stack.push(model); &#125; if (refreshModelBeforeResult) &#123; invocation.addPreResultListener(new RefreshModelBeforeResult(modelDriven, model)); &#125; &#125; return invocation.invoke(); &#125; /** * Refreshes the model instance on the value stack, if it has changed */ protected static class RefreshModelBeforeResult implements PreResultListener &#123; private Object originalModel = null; protected ModelDriven action; public RefreshModelBeforeResult(ModelDriven action, Object model) &#123; this.originalModel = model; this.action = action; &#125; public void beforeResult(ActionInvocation invocation, String resultCode) &#123; ValueStack stack = invocation.getStack(); CompoundRoot root = stack.getRoot(); boolean needsRefresh = true; Object newModel = action.getModel(); // Check to see if the new model instance is already on the stack for (Object item : root) &#123; if (item.equals(newModel)) &#123; needsRefresh = false; break; &#125; &#125; // Add the new model on the stack if (needsRefresh) &#123; // Clear off the old model instance if (originalModel != null) &#123; root.remove(originalModel); &#125; if (newModel != null) &#123; stack.push(newModel); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>struts2</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理]]></title>
    <url>%2Fdynamic-proxy%2F3699356932.html</url>
    <content type="text"><![CDATA[动态代理 动态代理简介在解释动态代理之前，我们先了解什么是代理，所谓代理，就类似生活当中的中介，例如，房产中介，其作用就是充当购房者与房地产商之间的桥梁。将这种思想应用到编程中便是我们所熟知的代理模式，而动态代理可以理解为代理模式下的一种具体的实现，即在实际的调用者与目标对象之间，存在着一个代理对象，这个代理对象可以在调用者访问目标对象时进行一些处理。在某些情况下，我们可能不希望某个对象直接去访问另一个对象，那么这个时候就可以使用代理对象去解决，动态代理的特点就是我们无需自己手动的创建代理对象，值得注意的是动态代理对象必须与目标对象实现相同的接口。 动态代理简单实现在Java的API中有一个Proxy类（java.lang.reflect.Proxy）,这个类中提供了一个可以获取动态代理对象的方法： 1static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 这个方法可以返回一个指定接口的代理类实例，也即是说这个方法可以根据所传的参数动态的返回某个类的代理类实例。为了演示这个过程，我先创建一个目标类： 被代理类12345678910package com.my.proxy;public class Target implements TestInterface &#123; @Override public void test() &#123; System.out.println("Target is running..."); &#125; &#125; 被代理类实现的接口1234567package com.my.proxy;public interface TestInterface &#123; void test();&#125; 测试代码如下： 测试类12345678910111213141516171819202122232425262728293031323334353637package com.my.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import org.junit.Test;public class TargetTest &#123; /** * 通过动态代理对象访问Target类中的方法 */ @Test public void test1() &#123; // 获取动态代理对象---在运行时在内存中动态地为Target创建一个虚拟的代理对象 // 参数：loader：与被代理类相同的类加载器；interfaces：被代理类所实现的接口的字节码对象数组 // dynamicProxy就是代理对象，由参数确定dynamicProxy是谁的代理对象 // 由于要调用被代理类中的方法，需要强制转换 TestInterface dynamicProxy = (TestInterface) Proxy.newProxyInstance(Target.class.getClassLoader() , new Class[]&#123;TestInterface.class&#125; , new InvocationHandler() &#123; // invoke表示执行代理对象的方法 // method表示的是目标对象的方法字节码对象 // args表示的是目标对象相应方法的参数 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 执行目标对象的方法 method.invoke(new Target(), args); // 此处的返回值可以是执行invoke方法返回的值 return null; &#125; &#125;); // 调用test()实际上执行的是invoke(),而invoke()又去调用目标对象的相应的方法 dynamicProxy.test(); &#125;&#125;]]></content>
      <categories>
        <category>dynamic_proxy</category>
      </categories>
      <tags>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持久层框架——Hibernate]]></title>
    <url>%2Fhibernate%2F1442904860.html</url>
    <content type="text"><![CDATA[开源的对象/关系映射框架–Hibernate Hibernate简介 Hibernate官网Hibernate是一个开源的对象/关系映射框架，或者说Hibernate是一个流行的持久层的框架，Hibernate对JDBC操作数据库的代码进行了轻量的封装，使得开发人员能够更自然地使用面向对象的方式操作数据库，大大简化了代码的编写。 Hibernate框架搭建Hibernate框架的搭建大致分为六个步骤： 1、导入Jar包2、创建数据库、数据表3、创建实体4、配置对象与表的映射5、配置主配置文件6、测试 搭建Hibernate框架所用到的必须的jar包，位于hibernate-release-5.3.1.Final\lib\required Hibernate映射文件实体类是普通(POJO)的Java类，并不具备持久化操作的能力，而映射文件能够将实体类中的属性映射到数据库中相应的的表字段中。Hibernate的映射文件通常以xxx.hbm.xml的形式命名，其中xxx指的是实体类名称，并且为了方便维护，映射文件通常放置在与实体类相同的目录下。例如将一个User实体类映射到数据库中的user表中： 实体类User.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.my.domain;import java.util.Date;public class User &#123; private String uid; private String username; private String password; private String email; private String telephone; private Date birthday; public String getUid() &#123; return uid; &#125; public void setUid(String uid) &#123; this.uid = uid; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getTelephone() &#123; return telephone; &#125; public void setTelephone(String telephone) &#123; this.telephone = telephone; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125;&#125; 创建user表123456789CREATE TABLE `user` ( `uid` varchar(32) NOT NULL, `username` varchar(20) DEFAULT NULL, `password` varchar(20) DEFAULT NULL, `email` varchar(30) DEFAULT NULL, `telephone` varchar(20) DEFAULT NULL, `birthday` date DEFAULT NULL, PRIMARY KEY (`uid`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 数据表与实体类都创建好之后便可以进行映射了: User.hbm.xml12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping package="com.my.domain"&gt; &lt;class name="com.my.domain.User" table="user"&gt; &lt;id name="uid" column="uid"&gt; &lt;generator class="native"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name="username" column="username"&gt;&lt;/property&gt; &lt;property name="password" column="password"&gt;&lt;/property&gt; &lt;property name="email" column="email"&gt;&lt;/property&gt; &lt;property name="telephone" column="telephone"&gt;&lt;/property&gt; &lt;property name="birthday" column="birthday"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 在上面的User.hbm.xml文件中，已经将实体类User映射到了数据库中的user表中，下面来看看映射文件中各个元素以及元素里面的属性的含义： 各个元素以及元素里面的属性的含义:hibernate-mapping : 映射文件的根元素，所有的都在中进行配置&ensp;&ensp;&ensp;&ensp;package属性：配置包名，如果配置了此属性，在元素内部凡是要填写完整类名的属性，可以直接写类名class : 定义与数据表进行映射的实体类&ensp;&ensp;&ensp;&ensp;name属性：实体类名称&ensp;&ensp;&ensp;&ensp;table属性：与实体类进行映射的表名称id : 配置实体类中唯一属性与数据表的主键进行映射&ensp;&ensp;&ensp;&ensp;name属性：实体类中用于与数据表主键进行映射的属性&ensp;&ensp;&ensp;&ensp;column属性：数据表主键generator : 指定主键的生成策略&ensp;&ensp;&ensp;&ensp;class属性：主键的生成策略（7个）：&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;identity：主键自增。由数据库来维护主键，录入时不需要指定主键&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;sequence：Oracle中的主键生成策略&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;increment：主键自增，由Hibernate维护，每次插入前先查询表中的id值，然后+1&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;Hilo：高低位算法，主键自增，由Hibernate维护&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;native：Hilo+sequence+identity，自动三选一策略&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;UUID：产生随机字符串作为主键，主键类型必须为String&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;assigned：自然主键生成策略，hibernate不会管理主键，由开发人员录入property : 除了主键数属性之外的普通属性的映射&ensp;&ensp;&ensp;&ensp;name属性：实体类中普通属性名称&ensp;&ensp;&ensp;&ensp;column属性：数据表中对应的列名称 以上只是映射文件中的部分元素及属性的含义。 Hibernate主配置文件Hibernate的映射文件负责实体类属性与数据库表字段之间的映射，而Hibernate主配置文件则负责配置连接持久层以及导入映射文件，Hibernate主配置文件有两种形式，一种是资源文件，即hibernate.properties,另一种是xml文件，hibernate.cfg.xml,两种文件的形式的主配置文件是等价的，但通常使用hibernate.cfg.xml来作为hibernate的主配置文件，因为xml格式的文件更容易修改。hibernate的主配置文件一般放置在src目录下。下面是一些常用的配置信息： hibernate主配置文件12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 数据库驱动 --&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;!-- 数据库URL --&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql:///hibernate?useSSL=false&amp;amp;serverTimezone=GMT%2B8&lt;/property&gt; &lt;!-- 数据库连接名 --&gt; &lt;property name="hibernate.connection.username"&gt;mackvord&lt;/property&gt; &lt;!-- 数据库连接密码 --&gt; &lt;property name="hibernate.connection.password"&gt;12345678&lt;/property&gt; &lt;!-- 指定数据库方言，MySQL5.x之后为MySQL5Dialect，5.x之前为MySQLDialect --&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt; &lt;!-- 配置hibernate生成的SQL语句打印到控制台 --&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;!-- 配置将打印到控制台的SQL语句进行格式化（语法缩进），便于阅读 --&gt; &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt; &lt;!-- 自动建表，如果表已经存在，则不再自动生成，如果表有改动则自动更新（不会删除原有的数据）--&gt; &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;!-- 指定hibernate操作数据库时的隔离级别,有四种选择，1表示读未提交；2表示读已提交；4表示可重复读；8表示串行化 --&gt; &lt;property name="hibernate.connection.isolation"&gt;4&lt;/property&gt; &lt;!-- 导入映射文件 --&gt; &lt;mapping resource="com/my/domain/User.hbm.xml" /&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; Hibernate作为当下最为流行的持久层框架之一，其所涉及到的知识远远不止以上这些，关于Hibernate其他的一些学习研究，以后有时间在继续更新。]]></content>
      <categories>
        <category>hibernate</category>
      </categories>
      <tags>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据库]]></title>
    <url>%2Fredis%2F3948062642.html</url>
    <content type="text"><![CDATA[非关系型数据库Redis Redis简介 Redis官网 Redis教程Redis是一种基于C语言编写的开源的内存存储数据结构，可用做数据库、缓存和消息队列，Redis使用键值对（key-value）的形式存储数据，由于其将数据存储在内存上而非磁盘上，因此具有较高的性能。 Redis支持的数据类型Redis支持五种数据类型：1、字符串（Strings）2、集合（Sets）3、列表（Lists）4、有序集合（Sorted Sets）5、散列（Hashs） Redis常用命令存储String类型数据 命令 描述 set key value 设置指定的key值 get key 获取指定的key值 getset key value 获取旧的value值，再将key的值设置为value incr key 将key中存储的数字增1 decr 将key中存储的数字减1 incrby key increment 将key所储存的值加上给定的增量值（increment） decrby key decrement 将key所储存的值减去给定的减量值（decrement） append key value 如果key已经存在并且是一个字符串，则将指定的value追加原来值的value的末尾，如果key不存在，则重新创建一个key/value strlen key 返回key所储存的字符串值的长度 存储List类型数据 List类型的数据与普通的链表一样，按照插入顺序进行排序，并且可以在list的头部或者尾部添加数据，一个List最多可以包含232 - 1个元素。关于存储list类型的数据的常用命令如下： 命令 描述 lpush key value1 value2… 将一个或多个值插入到列表头部 rpush key value1 value2… 在列表尾部中添加一个或多个值 lindex key index 通过索引获取列表中的元素 lrange key start end 获取列表指定范围内的元素,start、end可为负数，若为-1则表示链表尾部的元素 lpushx key value 将一个值插入到已存在的列表头部 rpushx key value 将一个值插入到已存在的列表尾部 lpop key 移出并获取列表的第一个元素 rpop key 移除并获取列表最后一个元素 rpoplpush source destination 移除列表的最后一个元素，并将该元素添加到另一个列表并返回 llen key 返回指定的key关联的链表中的元素的数量 lrem key count value 移除count个值为value的元素 linsert key before/after pivot value 在列表的pivot元素前或者后插入元素 存储Set类型数据 Set类型的数据可以理解为无序的、不重复的String类型的集合，其常用的命令如下： 命令 描述 sadd key value1 value2… 向set集合添加一个或多个数据 scard key 获取集合的成员的数量 smembers key 获取set集合中所有的成员 sismember key member 判断参数中指定的成员是否在该set中 srem key member1 member2… 移除set集合中一个或多个成员 srandmember key 随机返回set中的一个成员 sdiff key1 key2 返回key1与key2集合的差集 sdiffstore destination key1 key2 将key1与key2的差集存储在destination上 sinter key[key1,key2…] 返回指定集合的交集 sinterstore destination key1 key2 将key1与key2的交集存储在destination上 sunion key1 key2… 返回指定集合的并集 sunionstore destination key1 key2 将key1与key2的并集存储在destination上 存储Hash类型数据 Redis中Hash类型的数据其value值类似一个Map集合，因此比较适合存储对象。一个Hash最多可以包含232 - 1个键值对 命令 描述 hset key field value 将哈希表key中的字段field的值设为value hgetall key 获取key中的所有filed-vaule hget key field 获取指定的key的filed的值 hmset key fields 判断参数中指定的成员是否在该set中 hmset key field1 value1 [field2 value2 ] 同时将多个field-value(域-值)对设置到哈希表 key 中 hexists key field 判断哈希表指定的key中指定的字段是否存在 hlen key 获取key所包含的field的数量 hincrby key field increment 为哈希表key中的指定字段的整数值加上增量increment 存储Sorted Set类型数据 Sorted Set类型的数据是有序的，但是不允许重复，并且Sorted Set中的每一个元素都会有一个double类型的分数与之关联，Sorted Set类型的数据能够做到有序，也正是因为这个分数的存在，但是值得注意的是，分数是允许重复的，集合中的元素不能重复。由于这一特点，Redis可以用于游戏排名、微博热点话题等使用场景。其常用的命令如下： 命令 描述 zadd key score member score2 member2 向有序集合添加一个或多个成员，或者更新已存在成员的分数 zcard key 获取集合中的成员数量 zcount key min max 获取分数在[min,max]之间的成员 zcount key member 获取有序集中，成员的分数值 zrem key member [member …] 移除有序集合中的一个或多个成员 Java连接Redis在使用Java连接Redis之前，需要先进行安装，通常情况下，Redis安装在Linux系统中，操作之前先安装好并启动Redis。除此之外还需要用到两个Jar包：jedis-2.9.0.jar以及commons-pool2-2.6.0.jar 配置资源文件：jedis.properties12345redis.maxIdle=50redis.minIdle=10redis.maxTotal=50redis.url=localhostredis.port=6379 编写工具类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.my.utils;import java.io.IOException;import java.io.InputStream;import java.util.Properties;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;/** * Redis连接池工具类 * * @author Mackvord * @date 2018年7月20日 * @version 1.0 */public class JedisUtils &#123; /** * 定义连接池对象 */ private static JedisPool pool = null; static &#123; //加载配置文件 InputStream in = JedisUtils.class.getClassLoader().getResourceAsStream("jedis.properties"); Properties pro = new Properties(); try &#123; pro.load(in); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 创建池子的配置对象 JedisPoolConfig poolConfig = new JedisPoolConfig(); // 最大闲置数 poolConfig.setMaxIdle(Integer.parseInt(pro.get("redis.maxIdle").toString())); // 最小闲置数 poolConfig.setMinIdle(Integer.parseInt(pro.get("redis.minIdle").toString())); // 最大连接数 poolConfig.setMaxTotal(Integer.parseInt(pro.get("redis.maxTotal").toString())); // 创建连接池对象 pool = new JedisPool(poolConfig, pro.get("redis.url").toString(), Integer.parseInt(pro.get("redis.port").toString())); &#125; /** * 获取Redis连接对象的方法 * @return */ public static Jedis getJedis() &#123; return pool.getResource(); &#125;&#125; 编写测试类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.my.jedis;import org.junit.Test;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;/** * 测试连接Redis数据库 * * @author Mackvord * @date 2018年7月20日 * @version 1.0 */public class JedisTest &#123; @Test public void test() &#123; // 1.获取连接对象 Jedis jedis = new Jedis("localhost",6379); // 2.获取数据 String username = jedis.get("username"); System.out.println(username); // 3.存储数据 jedis.set("addr", "广州"); System.out.println(jedis.get("addr")); jedis.close(); &#125; /** * 通过Jedis的pool获取jedis连接 */ @Test public void test2() &#123; // 0.创建池的配置对象 JedisPoolConfig jpc = new JedisPoolConfig(); // 最大闲置数 jpc.setMaxIdle(30); // 最小闲置数 jpc.setMinIdle(10); // 最大连接数 jpc.setMaxTotal(50); // 1.创建jedis连接池对象 JedisPool jp = new JedisPool(jpc, "localhost", 6379); // 2.获取连接对象 Jedis jedis1 = jp.getResource(); // 3.操作数据库 jedis1.set("name", "Google"); System.out.println(jedis1.get("name")); // 4.关闭资源 jedis1.close(); jp.close(); &#125;&#125;]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传]]></title>
    <url>%2Fservlet%2F1496211386.html</url>
    <content type="text"><![CDATA[Java后台实现文件上传 写在前面文件上传的本质实际上就是文件的拷贝，只不过在具体的应用场景里面可能稍微有些差别，文件上传需要用到的外部jar包有两个，一个是fileupload.jar，另一个是的commons-io.jar，两个包都可以在Apache官网上去下载。文件上传的实现可能有很多种，在这里就讲一下最近学到的这种方法，如果以后发现有更好的实现，再继续补充！ 前端代码由于是示例，所以前端的代码只是一个简单的表单，代码如下： 12345678910111213141516&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath&#125;/uploadFile02" method="post" enctype="multipart/form-data"&gt; &lt;input type="text" name="username"&gt;&lt;br /&gt; &lt;input type="file" name="filename"&gt;&lt;br /&gt; &lt;input type="submit" value="上传文件"&gt;&lt;br /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 其中，表单的提交方式必须是post，enctype为multipart/form-data，还有一个就是文件上传所在的input标签必须要有name属性，因为在将文件拷贝到服务器上的过程中需要使用到文件名，整个表单提交到服务器的某个Servlet中。 后端代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.my.web;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.util.List;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.FileUploadException;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import org.apache.commons.io.IOUtils;public class UploadFileServlet02 extends HttpServlet &#123; private static final long serialVersionUID = 1L; public UploadFileServlet02() &#123; super(); &#125; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; try &#123; String temp_path = this.getServletContext().getRealPath("temp"); // 1.创建磁盘文件项工厂 // 作用：设置缓存文件大小 、设置临时文件的存储位置 // DiskFileItemFactory factory = new DiskFileItemFactory(1024*1024, new File(temp_path)); // 或者使用下面的方式 DiskFileItemFactory factory = new DiskFileItemFactory(); factory.setSizeThreshold(1024 * 1024); factory.setRepository(new File(temp_path)); // 2.创建文件上传的核心类 ServletFileUpload upload = new ServletFileUpload(factory); // 设置上传的文件名称的编码 upload.setHeaderEncoding("UTF-8"); // 2.1)判断是否是文件上传的表单 boolean multipartContent = upload.isMultipartContent(request); if (multipartContent) &#123; // 是文件上传的表单 // 1.解析request获得文件项集合 List&lt;FileItem&gt; parseRequest = upload.parseRequest(request); if (parseRequest != null) &#123; for (FileItem item : parseRequest) &#123; // 判断是否是普通的表单项 boolean formField = item.isFormField(); if (formField) &#123; String fieldName = item.getFieldName(); // 获取普通表单项的内容并指定其编码方式 String fileldvlaue = item.getString("UTF-8"); // 此处注意：当表单是enctype="multipart/form-data"类型时，request.getParameter相关的方法都失效 System.out.println(fieldName + ":" + fileldvlaue); &#125; else &#123; // 文件上传项 // 获取上传的文件名 String filename = item.getName(); // 获取上传的文件的内容 InputStream in = item.getInputStream(); // 指定文件上传到服务器的位置 String upload_path = this.getServletContext().getRealPath("upload"); // 创建输出流对象并指定上传文件写入到服务器的位置 OutputStream out = new FileOutputStream(new File(upload_path + File.separator + filename)); // 使用工具类进行文件拷贝 IOUtils.copy(in, out); in.close(); out.close(); // 删除临时文件 item.delete(); &#125; &#125; &#125; &#125; else &#123; // 普通文件表单 &#125; &#125; catch (FileUploadException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125;]]></content>
      <categories>
        <category>servlet</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Filter学习笔记一]]></title>
    <url>%2Ffilter%2F1313357525.html</url>
    <content type="text"><![CDATA[Filter过滤器 Filter简介Filter过滤器是运行在服务器上的程序，顾名思义，过滤器的作用就是对客户端访问资源的时候进行过滤，在进行过滤的时候主要是通过检查访问资源的请求头信息，检查完成后，如果条件符合，则放行，即正常调用请求的资源。如果不符合条件，则可以禁止访问该资源，此时可以将请求重定向到其他资源上或者执行一些其他的操作。使用过滤器，还可以对客户端的请求头信息或者服务器端的响应信息进行修改。 创建过滤器创建过滤器需要实现Filter接口，此接口定义了三个方法：初始化：init()、执行过滤：doFilter()、销毁：destory()，其中init()和destory()是接口默认的方法，doFilter()方法用于执行过滤代码，其定义如下： 12public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException; 可以看到doFilter()方法有三个参数：第一个参数request是ServletRequest对象，通过request过滤器可以访问各种请求信息，如果客户端发送的请求是HTTP请求，通常情况下可以将request对象强制转换为HttpServletRequest类型，这样便可以调用一些ServletRequest没有提供的方法；第二个参数是response是ServletResponse对象，一般情况下次参数可以忽略；第三个参数chain是FilterChain对象，此参数用于指定下一个过滤器。 除了实现Filter接口之外，还需要在web.xml配置过滤器与哪些资源相关联，例如： 12345678&lt;filter&gt; &lt;filter-name&gt;QuickFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.my.web.filter.QucikFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;QuickFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; url-pattern有三种写法1、完全匹配2、目录匹配3、扩展名匹配]]></content>
      <categories>
        <category>filter</category>
      </categories>
      <tags>
        <tag>Filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX学习笔记一]]></title>
    <url>%2Fajax%2F3311444737.html</url>
    <content type="text"><![CDATA[AJAX技术 AJAX简介什么是AJAX？W3School上是这样描述AJAX的：AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。AJAX并不是一种新的语言，而是一种使用现有的标准的新方法。使用AJAX能够使我们在不重新加载页面的情况下仍然可以与服务器进行数据交换，也就是说AJAX可以对网页的某个部分进行动态地更新。一个最常见的例子就是站内搜索。比如当我们使用百度进行搜索的时候，在我们输入关键字时，输入框的下方会弹出一个搜索建议列表，动态地向用户给出提示信息。 同步与异步在使用AJAX之前，首先需要明白什么是同步？什么是异步？同步是指客户端发送请求到服务器，在服务器响应之前，客户端都处于等待阻塞状态。而异步是指客户端发送请求到服务器，无论服务器是否响应，客户端都不会被阻塞。 原生的AJAX的技术原生的AJAX技术主要分为五个部分： 1、创建XMLHttpRequest 对象2、为XMLHttpRequest 对象绑定监听器3、指定提交的URL4、发送请求5、接收响应数据 1、创建XMLHttpRequest 对象 值得注意的是所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）都内建了 XMLHttpRequest 对象。 创建XMLHttpRequest对象1var xmlhttp = new XMLHttpRequest(); 2、为XMLHttpRequest 对象绑定监听器 为XMLHttpRequest 对象绑定监听器123xmlhttp.onreadystatechange=function()&#123; ...your code&#125; 3、指定提交的URL 1open(method,url,async) 方法 描述 open(method,url,async) 指定请求的类型、URL 以及是否异步处理请求 method：请求的类型；GET 或 POSTurl：资源文件的路径async：true（异步）或 false（同步） 4、发送请求 发送请求1xmlhttp.send(); 5、接收响应数据 响应数据一般在onreadystatechange事件就绪时执行的函数的内部接收： 123xmlhttp.onreadystatechange=function()&#123; // 此处接收响应数据&#125; Jquery的AJAX技术jQuery 库拥有完整的 Ajax 兼容套件。对 Js 原生的 AJAX 技术进行了封装，因此使用起来也更加方便，一般常用的方法有 $.get(url, [data], [callback], [type])$.post(url, [data], [callback], [type]) 以$.post(url, [data], [callback], [dataType])为例，其用法如下： 12345678$.post( &quot;$&#123;pageContext.request.contextPath&#125;/test01&quot;, &#123; name: &quot;bob&quot;, age: &quot;20&quot; &#125;, function(data)&#123; process(data); &#125;, &quot;json&quot;); 关于参数的描述 参数 描述 url 必须。指定把请求发送到哪个地址 data 可选。指定发送给服务器的数据 callback 可选。请求成功是执行的回调函数 dataType 可选。指定期望服务器返回的数据类型（JQuery会根据指定的类型自动类型转换）常用的返回类型有xml、json、script、html 使用AJAX异步处理完成站内搜索Demo首先自己写了一个简单的jsp页面，里面就一个搜索框以及提交按钮，效果如下： 初始页面代码12345678910111213141516171819202122232425262728293031323334353637383940&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;link rel="stylesheet" href="css/bootstrap.css" type="text/css" /&gt; &lt;script src="js/jquery-3.2.1.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script src="js/bootstrap.js" type="text/javascript"&gt;&lt;/script&gt; &lt;style&gt; .myclass1&#123; width:20%; float:left; margin:5px 5px; &#125; .myclass2&#123; position:absolute; margin:43px 5px; z-index:1000; background:#f0f3f5; width:266px; height:270px; border:solid 1px #ccc; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container-fluid"&gt; &lt;form class="navbar-form navbar-right" role="search"&gt; &lt;div class="form-group" style="position: relative"&gt; &lt;input id="search" type="text" class="form-control myclass1" placeholder="Search" onkeyup="searchWrod(this)"&gt; &lt;div id="showDiv" class="myclass2"&gt;&lt;/div&gt; &lt;button type="submit" class="btn btn-default" style="margin-top:5px"&gt;Submit&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 需求的分析，下面是整个查询业务的分析过程，由于水平有限，只能大概地画出代码的执行过程。 代码的实现，首先是在jsp文件中获取数据并发送到服务器，修改jsp文件中的代码，具体如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;link rel="stylesheet" href="css/bootstrap.css" type="text/css" /&gt; &lt;script src="js/jquery-3.2.1.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script src="js/bootstrap.js" type="text/javascript"&gt;&lt;/script&gt; &lt;style&gt; .myclass1&#123; width:20%; float:left; margin:5px 5px; &#125; .myclass2&#123; position:absolute; margin:43px 5px; z-index:1000; background:#f0f3f5; width:266px; border:solid 1px #ccc; display: none; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 搜索栏 --&gt; &lt;div class="container-fluid"&gt; &lt;form class="navbar-form navbar-right" role="search"&gt; &lt;div class="form-group" style="position: relative"&gt; &lt;input id="search" type="text" class="form-control myclass1" placeholder="Search" onkeyup="searchWrod(this)"&gt; &lt;div id="showDiv" class="myclass2"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default" style="margin-top:5px"&gt;Submit&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;!-- 站内搜索的实现 --&gt; &lt;script type="text/javascript"&gt; function overfun(obj)&#123; $(obj).css("background","#1093f3"); &#125; function outfun(obj)&#123; $(obj).css("background","#fff"); &#125; function clickfun(obj)&#123; // 点击选择时将内容设置到搜索输入框中并隐藏搜索提示框 $("#search").val($(obj).html()); $("#showDiv").css("display","none"); &#125; function searchWrod(obj)&#123; // 1.获取输入框中的内容 var keyword = $(obj).val(); // 2.根据输入框中的内容去数据库中进行模糊查询---List&lt;Product&gt; var content = ""; $.post( // 提交的URL "$&#123;pageContext.request.contextPath&#125;/searchWord", // 提交给服务器端的搜索关键字 &#123;"keyword":keyword&#125;, function(data)&#123; if (data.length &gt; 0) &#123; // 拼接div for (var i = 0; i &lt; data.length; i++) &#123; content += "&lt;div style='padding:5px 5px;cursor:pointer' onclick='clickfun(this)' onmouseover='overfun(this)' onmouseout='outfun(this)' &gt;" + data[i] + "&lt;/div&gt;"; &#125; // 3.将商品返回的商品名称显示在showDiv中 $("#showDiv").html(content); $("#showDiv").css("display","block"); &#125; &#125;, // 服务器返回的数据类型 "json" ); &#125; &lt;/script&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; WEB层的Servlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.my.web;import java.io.IOException;import java.sql.SQLException;import java.util.List;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.google.gson.Gson;import com.my.domain.Product;import com.my.service.SearchProductService;public class SearchWordServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public SearchWordServlet() &#123; super(); &#125; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 1.获取客户端发送过来的数据 String keyword = request.getParameter("keyword"); // 2.传递参数到service层 SearchProductService service = new SearchProductService(); List&lt;Product&gt; productList = null ; try &#123; productList = service.searchProductByKeyWord(keyword); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; // 3.使用工具类将productList转换为json格式的数据并返回给客户端 // jsonlib、gson(谷歌)、fastjson(阿里巴巴) Gson gson = new Gson(); String json = gson.toJson(productList); response.setContentType("text/html;charset=UTF-8"); response.getWriter().write(json); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; Service层的代码 12345678910111213141516package com.my.service;import java.sql.SQLException;import java.util.List;import com.my.dao.SearchProductDao;import com.my.domain.Product;public class SearchProductService &#123; public List&lt;Product&gt; searchProductByKeyWord(String keyword) throws SQLException &#123; SearchProductDao dao = new SearchProductDao(); return dao.searchProductByKeyWord(keyword); &#125;&#125; DAO层的代码 12345678910111213141516171819package com.my.dao;import java.sql.SQLException;import java.util.List;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanListHandler;import com.my.domain.Product;import com.my.utils.DataSourceUtils;public class SearchProductDao &#123; public List&lt;Product&gt; searchProductByKeyWord(String keyword) throws SQLException &#123; QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource()); String sql = "select * from product where pname like ? limit 0,6"; return qr.query(sql, new BeanListHandler&lt;Product&gt;(Product.class), "%" + keyword + "%"); &#125;&#125; 效果]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识事务]]></title>
    <url>%2Ftransaction%2F1774183904.html</url>
    <content type="text"><![CDATA[事务（transaction）的基本认识 事务的简介什么是事务？事务其实就是将一件事情中的n个组成单元组合到一起，这n个组成单元要么一起成功，要么一起失败。 事务的特性事务有四个特性：原子性、隔离性、持久性、一致性。 1、原子性：事务是个不可分割的单位，事务中的操作要么都成功，要么都失败2、一致性：在一个事务中，事务前后数据的完整性必须保持一致3、隔离性：多个事务之间互不干扰，相互隔离4、持久性：事务一旦提交，对数据库中数据的改变是永久性的 mysql中的事务 默认的事务：一条SQL语句就是一个事务，默认情况下开启并提交事务 手动事务：1、显式开启事务start transaction (connnection.setAutoCommit(false))；2、事务提交(commit)，从开启事务到提交事务之间所有的SQL语句都是有效的3、事务的回滚(rollback)：从开始事务到回滚事务之间所有的SQL语句都是无效的 使用原生的JDBC进行事务操作123456789101112131415161718192021222324252627282930313233343536373839package com.my.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class JDBCDemo &#123; public static void main(String[] agrs) &#123; Connection conn = null ; try &#123; // 注册数据库驱动（通过反射获取数据库驱动类） Class.forName("com.mysql.cj.jdbc.Driver"); // 获取数据库连接 conn = DriverManager.getConnection("jdbc:mysql:///mytomcat09?useSSL=false&amp;serverTimezone=GMT%2B8", "mackvord", "12345678") ; // 获取执行SQL语句的对象（平台） Statement statement = conn.createStatement(); // 手动开启事务，设置默认提交false。在mysql中，默认情况下每一条SQL语句都是一个事务，并且默认执行 conn.setAutoCommit(false); // 执行SQL操作 statement.executeUpdate("insert into account values(null,'tom',23000)"); statement.executeUpdate("insert into account values(null,'jack',15000)"); // 提交事务 conn.commit(); // 关闭资源 statement.close(); conn.close(); &#125; catch (Exception e) &#123; try &#123; // 回滚事务 conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; e.printStackTrace(); &#125; &#125;&#125; 使用DBUtilis进行事务处理以银行转账为例，一般银行转账需要转入账户的名称、转出的账户名称以及转账的金额，下面我将通过一个简单的例子模拟转账的场景，首先，我创建了一个jsp文件，里面写了一个简单的表单：表单1234567891011121314151617&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath&#125;/tranfer" method="post"&gt; 转入账户：&lt;input type="text" name="in"&gt;&lt;br /&gt; 转出账户：&lt;input type="text" name="out"&gt;&lt;br /&gt; 转账金额：&lt;input type="text" name="money"&gt;&lt;br /&gt; &lt;input type="submit" value="确认转账"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 然后新建一个Servlet Web层12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.my.tranfer.web;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.my.tranfer.service.TranferService;public class TranferServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public TranferServlet() &#123; super(); &#125; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获取三个参数：转入账户、转出账户、转账金额 String in = request.getParameter("in"); String out = request.getParameter("out"); String moneyStr = request.getParameter("money"); double money = Double.parseDouble(moneyStr) ; // 调用业务层的方法进行转账操作 TranferService service = new TranferService() ; boolean isTranferSuccess = service.tranfer(in, out, money); // 设置UTF-8编码 response.setContentType("text/html;charset=UTF-8"); if (isTranferSuccess) &#123; response.getWriter().write("转账成功！"); &#125; else &#123; response.getWriter().write("转账失败！"); &#125; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 新建TranferService类处理业务逻辑 Service层1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.my.tranfer.service;import java.sql.SQLException;import com.my.tranfer.dao.TranferDao;import com.my.utils.MyDataSourceUtils;public class TranferService &#123; /** * 业务层处理转账的方法 * @param in 转入的账户 * @param out 转出的账户 * @param money 转账金额 * @return isTranferSuccess记录转账是否成功 */ public boolean tranfer(String in, String out, double money) &#123; // 创建DAO层对象 TranferDao dao = new TranferDao() ; // 定义一个布尔类型的变量，记录转账是否成功 boolean isTranferSuccess = true ; Connection conn = null ; try &#123; // 获取连接 conn = DataSourceUtils.getConnection() ; // 开启事务 conn.setAutoCommit(false); // 转出钱的方法 dao.tranferOut(conn, out, money) ; // 模拟异常 //int i = 1/0 ; // 转入钱的方法 dao.tranferIn(conn, in, money) ; &#125; catch (Exception e) &#123; // 出现异常后将isTranferSuccess设置为false isTranferSuccess = false; try &#123; // 回滚事务 conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; e.printStackTrace(); &#125; finally &#123; try &#123; // 提交事务 conn.commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return isTranferSuccess ; &#125;&#125; 创建TranferDao类 DAO层12345678910111213141516171819202122232425262728293031323334package com.my.tranfer.dao;import java.sql.Connection;import java.sql.SQLException;import org.apache.commons.dbutils.QueryRunner;import com.my.utils.MyDataSourceUtils;public class TranferDao &#123; /** * 转入金额的方法 * @param in 转入的账户 * @param money 转入的金额 * @throws SQLException */ public void tranferIn(Connection conn, String in, double money) throws SQLException &#123; QueryRunner runner = new QueryRunner() ; String sql = "update account set money = money+? where name = ?" ; runner.update(conn, sql, money, in) ; &#125; /** * 转出金额的方法 * @param out 转出的账户 * @param money 转出的金额 * @throws SQLException */ public void tranferOut(Connection conn, String out, double money) throws SQLException &#123; QueryRunner runner = new QueryRunner() ; String sql = "update account set money = money-? where name = ?" ; runner.update(conn, sql, money, out) ; &#125;&#125; 其中用到的工具类以及xml文件代码如下： DataSourceutils工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.my.utils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import javax.sql.DataSource;import com.mchange.v2.c3p0.ComboPooledDataSource;public class DataSourceUtils &#123; private static DataSource dataSource = new ComboPooledDataSource(); private static ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;Connection&gt;(); // 直接可以获取一个连接池 public static DataSource getDataSource() &#123; return dataSource; &#125; // 获取连接对象 public static Connection getConnection() throws SQLException &#123; return dataSource.getConnection() ; &#125; // 获取当前的连接对象 public static Connection getCurrentConnection() throws SQLException &#123; Connection con = tl.get(); if (con == null) &#123; con = dataSource.getConnection(); tl.set(con); &#125; return con; &#125; // 开启事务 public static void startTransaction() throws SQLException &#123; Connection con = getCurrentConnection(); if (con != null) &#123; con.setAutoCommit(false); &#125; &#125; // 事务回滚 public static void rollback() throws SQLException &#123; Connection con = getCurrentConnection(); if (con != null) &#123; con.rollback(); &#125; &#125; // 提交并且 关闭资源及从ThreadLocall中释放 public static void commitAndRelease() throws SQLException &#123; Connection con = getCurrentConnection(); if (con != null) &#123; // 事务提交 con.commit(); // 关闭资源 con.close(); // 从线程绑定中移除 tl.remove(); &#125; &#125; // 关闭资源方法 public static void closeConnection() throws SQLException &#123; Connection con = getCurrentConnection(); if (con != null) &#123; con.close(); &#125; &#125; public static void closeStatement(Statement st) throws SQLException &#123; if (st != null) &#123; st.close(); &#125; &#125; public static void closeResultSet(ResultSet rs) throws SQLException &#123; if (rs != null) &#123; rs.close(); &#125; &#125;&#125; c3p0.xml123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;c3p0-config&gt; &lt;default-config&gt; &lt;property name="driverClass"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql:///mytomcat09?useSSL=false&amp;amp;serverTimezone=GMT%2B8&lt;/property&gt; &lt;property name="user"&gt;mackvord&lt;/property&gt; &lt;property name="password"&gt;12345678&lt;/property&gt; &lt;property name="initialPoolSize"&gt;5&lt;/property&gt; &lt;property name="maxPoolSize"&gt;20&lt;/property&gt; &lt;/default-config&gt;&lt;/c3p0-config&gt; 可以看到，上面的代码关于事务的处理是在service层中，但是有一点不好的地方是在Servlet层中创建了Connection对象，由于事务的处理需要先取得对应的Connection对象，所以为了保证获取到正确的连接对象并且避免在service层中创建Connection对象，可以新建一个工具类，使用TreadLocal绑定连接对象。 改进后的工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.my.utils;import java.sql.Connection;import java.sql.SQLException;import com.mchange.v2.c3p0.ComboPooledDataSource;/** * 封装事务提交、回滚、获取连接、绑定线程资源的操作 * @author LQZ * @date 2018年7月15日 * @version 1.0 */public class MyDataSourceUtils &#123; /** * 创建dataSource对象 */ private static ComboPooledDataSource dataSource = new ComboPooledDataSource() ; /** * 创建本地线程绑定连接(Map集合) */ private static ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;Connection&gt;() ; /** * 创建新的Connection对象 * @return Connection对象 * @throws SQLException */ public static Connection getConnection() throws SQLException &#123; return dataSource.getConnection(); &#125; /** * 获取线程池中绑定的连接 * @return * @throws SQLException */ public static Connection getCurrentConnection() throws SQLException &#123; // 获取当前线程绑定的连接 Connection conn = tl.get(); if (conn == null) &#123; // 如果当前线程没有绑定的连接，则创建一个新的连接 conn = getConnection(); // 将新创建的连接绑定到ThreadLocal中 tl.set(conn); &#125; return conn ; &#125; /** * 开启事务的方法 * @throws SQLException */ public static void startTransaction() throws SQLException &#123; Connection conn = MyDataSourceUtils.getCurrentConnection(); conn.setAutoCommit(false); &#125; /** * 回滚事务的方法 * @throws SQLException */ public static void rollback() throws SQLException &#123; MyDataSourceUtils.getCurrentConnection().rollback(); &#125; /** * 提交事务的方法 * @throws SQLException */ public static void commit() throws SQLException &#123; Connection conn = getCurrentConnection(); conn.commit(); tl.remove(); conn.close(); &#125;&#125; 重新修改service层的代码： 修改后的TranferService类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.my.tranfer.service;import java.sql.SQLException;import com.my.tranfer.dao.TranferDao;import com.my.utils.MyDataSourceUtils;/** * 业务层方法，进行业务逻辑的处理 * @author LQZ * @date 2018年7月15日 * @version 1.0 */public class TranferService &#123; /** * 业务层处理转账的方法 * @param in 转入的账户 * @param out 转出的账户 * @param money 转账金额 * @return isTranferSuccess记录转账是否成功 */ public boolean tranfer(String in, String out, double money) &#123; // 创建DAO层对象 TranferDao dao = new TranferDao() ; // 定义一个布尔类型的变量，记录转账是否成功 boolean isTranferSuccess = true ; try &#123; // 开启事务+ MyDataSourceUtils.startTransaction(); // 转出钱的方法+ dao.tranferOut(out, money) ; // 转入钱的方法+ dao.tranferIn(in, money) ; &#125; catch (Exception e) &#123; // 出现异常后将isTranferSuccess设置为false isTranferSuccess = false; try &#123; // 回滚事务+ MyDataSourceUtils.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; e.printStackTrace(); &#125; finally &#123; try &#123; // 提交事务+ MyDataSourceUtils.commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return isTranferSuccess ; &#125;&#125; 修改DAO层的代码： 修改后的TranferDao类123456789101112131415161718192021222324252627282930313233343536373839404142package com.my.tranfer.dao;import java.sql.Connection;import java.sql.SQLException;import org.apache.commons.dbutils.QueryRunner;import com.my.utils.MyDataSourceUtils;/** * DAO层的方法，进行数据库操作 * @author LQZ * @date 2018年7月15日 * @version 1.0 */public class TranferDao &#123; /** * 转入金额的方法 * @param in 转入的账户 * @param money 转入的金额 * @throws SQLException */ public void tranferIn(String in,double money) throws SQLException &#123; QueryRunner runner = new QueryRunner() ;+ Connection conn = MyDataSourceUtils.getCurrentConnection(); String sql = "update account set money = money+? where name = ?" ;+ runner.update(conn, sql, money, in) ; &#125; /** * 转出金额的方法 * @param out 转出的账户 * @param money 转出的金额 * @throws SQLException */ public void tranferOut(String out, double money) throws SQLException &#123; QueryRunner runner = new QueryRunner() ;+ Connection conn = MyDataSourceUtils.getCurrentConnection();+ String sql = "update account set money = money-? where name = ?" ; runner.update(conn, sql, money, out) ; &#125;&#125; 在进行转账操作的时候会涉及到减去金额（转出账户），增加金额（转入账户），而事务的目的就是要确保转账的整个过程要么成功要么失败，避免出现转出账户金额减少了但转入账户金额却没有增加等一些异常情况的出现。 隔离性在并发访问下引发的问题 脏读：A读取到B尚未提交的数据 不可重复读：在同一个事务中，两次读取的数据内容不一致 虚读/幻读：在一个事务中，两次读取的数据条数不一致 事务的隔离级别 read uncommitted：读取尚未提交的数据—-无法解决脏读、不可重复读、虚读/幻读等问题 read committed：读取已经提交的数据—-Oracle默认的隔离级别，可以解决脏读问题 repeatable read：重复读取—-mysql默认的隔离级别，可以解决脏读以及不可重复读的问题 serializable：串行化，安全级别最高—可以解决脏读、不可重复读、虚读/幻读问题 事务的隔离级别并不是越高越好，事务的安全级别越高其性能就越低，查看mysql中的事务隔离安全级别的命令：select @@tx_isolation，设置事务隔离安全级别的命令：set session transaction isolation level 安全级别。]]></content>
      <categories>
        <category>transaction</category>
      </categories>
      <tags>
        <tag>事务</tag>
        <tag>transaction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP学习笔记(1)]]></title>
    <url>%2Fjsp%2F2400782540.html</url>
    <content type="text"><![CDATA[运行在服务器端的动态网页技术–JSP JSP简介JSP全称为Java Server Pages，是基于Servlet建立的一种动态网页技术标准，相比传统的HTML页面，使用JSP技术可以在HTML页面中嵌入Java代码。点击此处了解更多关于JSP技术的信息。 JSP脚本想要使用JSP脚本，有三种方式，其语法如下： &lt;% java代码 %&gt; &lt;%= java表达式 %&gt; &lt;%! java代码 %&gt; 关于三种语法形式的区别如下表， 语法形式 区别 &lt;% java代码 %&gt; 代码在服务器端执行时会被放到service()方法内部执行 &lt;%= java表达式 %&gt; 代码会被放到service()方法内部的out.print(java表达式)中执行 &lt;%! java代码 %&gt; 代码会被放到service()方法的外部，类的内部，作为成员内容执行 JSP注释JSP文件中有三种注释方式 HTML注释： Java注释：由于使用Java作为脚本语言，所以JSP文件支持Java的注释方式，包括单行(//)、多行(/**/)与文档注释(/** */) JSP注释：&lt;%– JSP注释 –%&gt; 在JSP文件中，不同的注释其可见范围是不一样的 JSP支持的注释 可见范围 HTML注释 JSP源码、翻译后的Servlet、HTML源码 Java注释 翻译后的Servlet、HTML源码 JSP注释 JSP源码 JSP运行原理jsp文件在第一次被访问时会Web容器翻译成Servlet程序并编译运行。编译运行后的文件存放在Tomcat安装目录/work/Catalina/localhost/项目名称/org/apache/jsp路径下。 JSP指令JSP指令用来设置整个页面的相关属性，比如页面编码、引入标签库等。JSP文件中可以设置三个指令，每个指令有不同的属性。 指令： JSP指令 描述 &lt;%@page …%&gt; 定义网页的一些基本属性，例如：编码、错误页面、是否使用session等 &lt;%@include …%&gt; 页面包含 &lt;%@taglib …%&gt; 引入标签库 Page指令常用属性： Page指令属性 描述 pageEncoding 当前jsp文件的编码 import 导入java包 language jsp文件中嵌入的语言类型 contextType 指定当前JSP页面的MIME类型和字符编码 session 指定JSP页面是否使用session errorPage 指定当前JSP页面发生异常时需要跳转到的错误处理页面 isErrorPage 指定当前页面是否可以作为另一个JPS页面的错误页面 extends 指定JSP页面翻译后的Servlet要继承的类 include指令：文件包含指令或者说页面包含指令（静态页面），即可以将一个JSP页面包含到另一个JSP页面中，其语法如下：&lt;%@include file=”文件地址” %&gt;，此处的地址是一个相对的地址。 taglib指令：此指令用于引入自定义的标签库，其语法如下：&lt;%@taglib uri=&quot;标签库地址&quot; prefix=&quot;标签前缀&quot;&gt;，标签前缀可以自由定义。 JSP隐式对象JSP中的隐式对象由容器负责创建，因此可以直接使用。 对象 类型 描述 request ServletRequest 获取用户请求信息 response ServletResponse 服务器响应信息 config ServletConfig 服务器配置，获取初始化参数 page Object 指定当前页面转换后的Servlet类实例 session HttpSession 保存用户信息 pageContext PageContext JSP页面容器 application ServletContext 所有用户的共享信息 out JspWriter 页面输出 exception Exception JSP页面所发生的异常，只在错误页面起作用 四个作用域的范围 page域：当前JSP页面session域：一次会话application域：整个web应用request域：一次请求 部分示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;%@ page language="java" contentType="text/html; charset=UTF-8" session="true" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- html注释 --&gt; &lt;%-- JSP注释 --%&gt; // 单行注释 /* 多行注释 */ /** 文档注释 */ &lt;!-- 文本最终会由out.write()方法输出 --&gt; this is a test ! &lt;% // 九大隐式对象，由容器自动创建 // 由于Out缓冲区中的数据最终会被加载到response缓冲区中，所以out.write()输出的数据会在response.getWriter().write()之后 // 1.out对象 out.write("-- 隐式对象：Out") ; // 2.response对象 response.getWriter().write("隐式对象：response --") ; // 3.request对象 request.setAttribute("JSESSIONID", request.getSession().getId()) ; // 4.pageContext域对象,此对象可以向其他指定的域中存取数据 // 向请求域中设置属性 request.setAttribute("age", "17"); // page域 pageContext.setAttribute("age", "16"); // request域 pageContext.setAttribute("age", "18", PageContext.REQUEST_SCOPE); // session域 pageContext.setAttribute("age", "19", PageContext.SESSION_SCOPE); // application域 pageContext.setAttribute("age", "20", PageContext.APPLICATION_SCOPE); %&gt;&lt;br /&gt; &lt;%="JSESSIONID: " + (String)request.getAttribute("JSESSIONID")%&gt; &lt;%-- findAttribuite()方法默认会从小到大搜索域范围中的age,其大小关系为 page域&lt;request域&lt;session域&lt;application域 --%&gt; &lt;%=pageContext.findAttribute("age") %&gt; &lt;%= "age= " + pageContext.getAttribute("age", PageContext.REQUEST_SCOPE)%&gt; &lt;%-- pageContext对象可以获得其他八个隐式对象 --%&gt; &lt;% pageContext.getException(); pageContext.getOut(); pageContext.getPage(); pageContext.getRequest(); pageContext.getResponse(); pageContext.getServletConfig(); pageContext.getServletContext(); pageContext.getSession(); %&gt; &lt;%! int i = 8 ; %&gt; &lt;%-- 转发指令 --%&gt; &lt;jsp:forward page="/include.jap" &gt;&lt;/jsp:forward&gt;&lt;/body&gt;&lt;/html&gt; EL表达式EL表达式的作用主要就是简化JSP代码的编写，提高代码的可维护性。 内置对象 对象 描述 pageScope 用于获取JSP域中的数据 requestScope 用于获取JSP域中的数据 sessionScope 用于获取JSP域中的数据 applicationScope 用于获取JSP域中的数据 parma 接收参数 parmaValues 接收参数 header 获取请求头部信息 headerValues 获取请求头部信息 initParma 获取全局初始化参数 cookie 获取Cookie数据 pageContext 获取其他8个隐式对象 JSTL所谓JSTL即JSP标准标签库，是一个JSP标签集合，在JSP页面中使用JSTL可以完成一些业务逻辑代码的编写。根据JSTL标签的功能可以分五部分，核心标签（core）、格式化标签（I18N）、SQL标签、XML标签、JSTL函数标签（functions）。目前最新的是2015年发布的Standard 1.2.3,下载地址。 下面是一些代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ page import="java.util.*" %&gt;&lt;%@ page import="com.my.domain.*" %&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% // 模拟list&lt;String&gt;,输出集合中的数据 List&lt;String&gt; strList = new ArrayList&lt;String&gt;() ; strList.add("Alibaba") ; strList.add("Amazon") ; strList.add("Google") ; strList.add("Apple") ; strList.add("Baidu") ; strList.add("Tencent") ; request.setAttribute("strList", strList) ; // 遍历List&lt;User&gt;中的所有数据 List&lt;User&gt; userList = new ArrayList&lt;User&gt;() ; // User为实体类 User user1 = new User() ; user1.setId("1") ; user1.setName("Tom"); user1.setPassword("123") ; userList.add(user1) ; User user2 = new User() ; user2.setId("1") ; user2.setName("Jerry"); user2.setPassword("123") ; userList.add(user2) ; application.setAttribute("userList", userList) ; // 遍历Map&lt;String, String&gt;中的所有数据 Map&lt;String,String&gt; strMap = new HashMap&lt;String, String&gt;(); strMap.put("name","Jerry") ; strMap.put("email","jerry@163.com") ; strMap.put("addr","guangzhou") ; strMap.put("age","20") ; session.setAttribute("strMap", strMap) ; %&gt; &lt;%-- 取出strList中的数据 --%&gt; &lt;h3&gt;forEach取出strList中的数据&lt;/h3&gt; &lt;c:forEach items="$&#123;strList&#125;" var="str"&gt; &lt;!-- 换行是为了避免字符串覆盖 --&gt; $&#123;str&#125;&lt;br /&gt; &lt;/c:forEach&gt; &lt;h3&gt;forEach取出userList中的数据&lt;/h3&gt; &lt;c:forEach items="$&#123;userList&#125;" var="user"&gt; Username:$&#123;user.name&#125;-- Password:$&#123;user.password&#125;&lt;br /&gt; &lt;/c:forEach&gt; &lt;h3&gt;forEach取出strMap中的数据&lt;/h3&gt; &lt;c:forEach items="$&#123;strMap&#125;" var="map"&gt; $&#123;map.key&#125;: $&#123;map.value&#125;&lt;br /&gt; &lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>jsp</category>
      </categories>
      <tags>
        <tag>jsp</tag>
        <tag>jsp简介</tag>
        <tag>jsp注释</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie & Session]]></title>
    <url>%2Fsession-cookie%2F2682590331.html</url>
    <content type="text"><![CDATA[会话技术－－Cookie &amp; Session 写在前面我们都知道HTTP协议是无状态的，也就是说其对事务的处理是没有记忆能力的，这种无状态的特性一方面缓解了服务器的压力，但另一方面每次请求都会传输大量的重复信息，所以在一定程度上这种无状态的特性阻碍了动态交互的Web应用的实现。而Session和Cookie这两种用于保持HTTP协议连接状态的技术就在这样的背景下应运而生了。 Session技术所谓Session指的是会话控制，Session会话在用户访问时建立，在关闭浏览器的时候断开（并不是在关闭页面时断开）。Session技术为客户端与服务器端保持状态提供解绝方案。与Cookie不同的是，Session是保存在服务器中的，当客户端访问服务器时，服务器根据需要产生Session并将会话ID发送给客户端，并且在发送之前服务器会检查客户端的请求中是否已包含有会话ID，如果已经包含有一个会话ID，说明此前已经为客户端创建过一个Session，此时服务器会利用客户端发送的请求中的会话ID检索相应的Session。会话ID会被保存在浏览器的内存中，如果浏览器关闭，会话ID也将被清除掉。 创建Session1234567// 获取Session对象,服务器会先检测客户端的请求中是否包含JSESSIONID（即会话ID），如果有则不再创建新的Session对象,否则创建一个新的Session对象并返回HttpSession session = request.getSession();// 获取Session ID(JSESSIONID)String id = session.getId();// Session本质上也是一个域对象，因此可以使用setAttribute() || getAttribute() || remoteAttribute()这三个方法session.setAttribute("name", "Tom");response.getWriter().write("JSESSIONID: " + id); Session的生命周期创建：第一次执行request.getSession()时创建销毁：1、服务器关闭，包括非正常关闭；2、session过期（默认30分钟），从不操作服务器资源开始计算；3、手动销毁，session.invalidate() JSESSIONID持久化为什么要设置JSESSIONID持久化？原因很简单：Session技术是借助Cookie来存储JSESSIONID的，所以当浏览器被关闭时，JSESSIONID将会被清除，此时客户端再去访问服务器时，由于没有JSESSIONID，所以服务器会为客户端创建一个新的session，那么上一次客户端访问时服务器开辟的内存空间中的数据就无法取出。典型的例子就是购物车 1234// JESSIOINID持久化Cookie cookie = new Cookie("JSESSIONID", id) ;cookie.setPath("/MyTomcat05");cookie.setMaxAge(60*10); Cookie技术Cookie简介首先，Cookie指的并不是”曲奇饼”，而是指网站为了辨别用户身份而存储在用户本地终端上的数据，而且通常都会被加密。由网景公司的前雇员Lou Montulli在1993年3月的发明。Cookie由服务器产生，发送给客户端（浏览器），客户端会将Cookie中的数据保存到某个目录下的文本文件中，如果浏览器设置了启用Cookie，那么在下一次请求访问服务器（同一网站）资源的时候会将Cookie发送给服务器。Cookie中的key和value由服务器自己定义，例如： 创建一个Cookie并发送给客户端1234String key = "name"String value = "Alice"Cookie cookie = new Cookie(key,value) ;response.addCookie(cookie) ; 注意： Cookie中不能存储中文。 Cookie的主要作用1、判断注册用户是否已经登录网站 2、事物处理 Cookie的生命周期Cookie在服务器创建时可以指定一个到期（Expire）的时间，如果服务器在创建Cookie对象时，没有设置到期时间，那么Cookie的默认到期时间与Session 会话的时间一致，也就是说会话关闭时，Cookie也就随之消失。 12345// 2.设置持久化时间,参数为秒,如果不设置，默认情况下Cookie的生命周期为Session会话的生命周期// 如果希望删除Cookie信息，只需要将Cookie的到期时间设置为0即可，如：cookie.setMaxAge(0);cookie.setMaxAge(60);// 3.设置Cookie的携带路径，即访问哪些路径下的资源需要携带Cookie信息cookie.setPath("/MyTomcat05/cookieServlet"); 通常情况下，Cookie信息可以保持登录状态一段时间，这在某种程度上可以提升用户体验，用户不必频繁地输入账户密码，但是也存在一定的安全隐患，因此在会话结束时，应该及时清除Cookie信息。 Session与Cookie的区别 &ensp; Session Cookie 区别 Session机制是客户端与服务器之间保持状态的解决方案 Cookie机制是客户端保持状态的解决方案 联系 Session机制需要借助Cookie机制来在客户端保存会话ID]]></content>
      <categories>
        <category>session_cookie</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet]]></title>
    <url>%2Fservlet%2F335668945.html</url>
    <content type="text"><![CDATA[Servlet容器 写在前面 Servlet基础教程 request常用方法使用request获取Header信息，包括请求头、请求行、请求体 request获取请求头信息 &ensp; request.getHeader(name) &ensp; request获取请求行信息 &ensp; 获取请求方式 request.getMethod() 获取请求的URI地址 request.getRequestURI() 获取请求的URL地址 request.getRequestURL() 获取Web应用的名称 request.getContextPath() 获取远程客户端的ip地址 request.getRemoteAddr() 返回类型 request获取请求体信息 String request.getParameter(name) Map&lt;String, String[]&gt; request.getParameterMap() String[] request.getParameterValues(name)]]></content>
      <categories>
        <category>servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat]]></title>
    <url>%2Ftomcat%2F2515320506.html</url>
    <content type="text"><![CDATA[Apache Tomcat 写在前面Tomcat是一个开源的Web应用服务器，是Apache软件基金会旗下的一个项目，使用Tomcat部署Web应用时访问HTML页面实际上是通过Servlet和JSP进行的，项目官网，目前最新版本是9.0.10 快速入门在Tomcat官网上提供有解压版和安装版两个版本的Tomcat，可根据自己的需要选择安装，安装过程比较简单，这里步骤就不贴出来了，验证是否安装成功只需要在浏览器里访问http://localhost:8080即可，如果出现Tomcat的欢迎页面即表示安装成功，例如我安装的是Tomcat 9，出现下面的页面即为安装成功： 安装成功后就可以使用Tomcat来部署第一个Web应用，在浏览器输出Hello World !1、首先在eclipse中创建一个动态的Web工程：File --&gt; new --&gt; other --&gt; Web --&gt; Dynamic Web Project 此处如果发现无法选择Tomcat的版本，可以在eclipse中配置runtime environment，具体的路径：Preferences –&gt; Server –&gt; Runtime Environment –&gt; Add –&gt; 选择自己安装的版本即可 2、在项目名称 --&gt; java Resources --&gt; src下新建一个Servlet，URL mapping可以根据自己的需要设置 创建完Servlet之后会得到一段默认的代码： 123456789101112131415161718192021222324252627282930313233343536373839package com.my.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class HelloServlet */public class HelloServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public HelloServlet() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub response.getWriter().append("Served at: ").append(request.getContextPath()); &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub doGet(request, response); &#125;&#125; 接下来就修改doGet()中的代码实现在浏览器中输出Hello World ！ 12345protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub //response.getWriter().append("Served at: ").append(request.getContextPath()); response.getWriter().write("Hello World !");&#125; 4、部署Web项目到Tomcat服务器中：项目名称 --&gt; Run As --&gt; Run on Server --&gt; Finish 5、在浏览器中访问：http://localhost:8080/项目名称/url mapping，我这里是http://localhost:8080/MyFristTomcat/HelloServlet，成功输出Hello World ！]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库连接池]]></title>
    <url>%2Fdatabase%2F1664209794.html</url>
    <content type="text"><![CDATA[自定义连接池、DBCP、C3P0、DRUID 写在前面 百度百科关于数据库连接池的介绍 数据库连接池主要解决的就是连接性能的问题，因为频繁地建立和关闭连接是一件相当耗费性能的事情，尤其是在访问量比较大的时候，所以如何合理分配、管理数据库连接就变得尤为重要，下面列举了四种数据库连接池技术，包括自定义连接池、使用C3P0、DBCP、DRUID创建数据库连接池。 自定义连接池创建自定义连接池的方法也很简单，只需要将连接放到集合(容器)中，当用户需要连接数据库时，不是直接创建连接而是获取连接池中已经创建好连接，这在一定程度上可以提高性能。当然，在实际的项目中通常不会使用自定义的连接池，这里仅仅作为演示。首先要创建一个properties文件，设置连接参数，包括驱动(driver)、数据库连接地址(url)、用户名(username)、密码(password)，例如： properties文件1234driver=com.mysql.cj.jdbc.Driverurl=jdbc:mysql:///test?useUnicode=true&amp;useSSL=false&amp;serverTimezone=GMT%2B8&amp;character=utf8username=mackvordpassword=12345678 最新版本的MySQL驱动，其注册地址是com.mysql.cj.jdbc.Driver而不是com.mysql.jdbc.Driver，并且必须要设置useSSL和serverTimezone两个参数，否则会报错（警告） JdbcUtils工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.jdbc.utils;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.Properties;public class JdbcUtils &#123; private static String driver ; private static String url ; private static String username ; private static String password ; /** * 静态代码块加载配置文件 */ static &#123; // 方法1 // 1.获取当前类的类加载器 ClassLoader classLoader = JdbcUtils.class.getClassLoader() ; // 2.加载src资源 InputStream is = classLoader.getResourceAsStream("db.properties") ; // 3.创建properties对象 Properties props = new Properties() ; // 4.加载指定的流 try &#123; props.load(is) ; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 5.使用getProperty(key)方法获取key对应的value值 driver = props.getProperty("driver") ; url = props.getProperty("url") ; username = props.getProperty("username") ; password = props.getProperty("password") ; /*// 方法2 ResourceBundle bundle = ResourceBundle.getBundle("db"); driver = bundle.getString("driver") ; url = bundle.getString("url") ; username = bundle.getString("username") ; password = bundle.getString("password") ;*/ &#125; /** * 获取数据库连接的方法 * * @return */ public static Connection getConnection() &#123; Connection conn = null ; try &#123; Class.forName(driver) ; conn = DriverManager.getConnection(url, username, password) ; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return conn ; &#125; /** * 释放资源的方法 * * @param conn 数据库连接对象 * @param ps 执行SQL语句的对象 * @param rs 结果集 */ public static void release(Connection conn, PreparedStatement ps, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (ps != null) &#123; try &#123; ps.close() ; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; MyDataSource类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.jdbc.datasource;import java.io.PrintWriter;import java.sql.Connection;import java.sql.SQLException;import java.sql.SQLFeatureNotSupportedException;import java.util.LinkedList;import java.util.logging.Logger;import javax.sql.DataSource;import testjunit.com.JdbcUtils;public class MyDataSource implements DataSource &#123; /** * 1.创建数据库连接池对象 */ private static LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;() ; // 2.创建连接池,假设创建五个连接 static &#123; for (int x = 0 ; x &lt; 5 ; x++) &#123; Connection conn = JdbcUtils.getConnection() ; //放入连接池中的连接已经被装饰过 MyConnection mc = new MyConnection(conn, pool) ; pool.add(mc) ; &#125; &#125; /** * 获取数据库连接池中的连接的方法 */ @Override public Connection getConnection() throws SQLException &#123; Connection conn = null ; // 3.使用连接池之前先判断 if (pool.size() == 0) &#123; for (int x = 0 ; x &lt; 5 ; x++) &#123; conn = JdbcUtils.getConnection() ; // 放入连接池中的连接已经被装饰过 MyConnection mc = new MyConnection(conn, pool) ; pool.add(mc) ; &#125; &#125; // 4.获取一个连接对象并返回 conn = pool.remove(0) ; return conn ; &#125; /** * 将连接返还到连接池中的方法 * @param conn 调用此的对象的连接 */ public void backConnection(Connection conn) &#123; pool.add(conn) ; &#125; // 此处省略部分没有实现的方法&#125; 上面的代码在创建连接池的时候，没有直接将连接添加到连接池中，而是通过一个装饰类MyConnection包装后再添加到连接池中，这样做的主要原因是当用户操作完成后会调用release()方法释放资源，而release()方法中又调用了close()，如果每个用户在执行完操作后直接将连接关闭，那么连接池中的连接就会被消耗殆尽，所以理想的情况应该是用户在执行完操作后将连接归还到连接池中，为了实现这一操作，可以定义一个新的类MyConnection实现Connection接口并重写close()方法。 MyConnection类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.jdbc.datasource;import java.sql.Array;import java.sql.Blob;import java.sql.CallableStatement;import java.sql.Clob;import java.sql.Connection;import java.sql.DatabaseMetaData;import java.sql.NClob;import java.sql.PreparedStatement;import java.sql.SQLClientInfoException;import java.sql.SQLException;import java.sql.SQLWarning;import java.sql.SQLXML;import java.sql.Savepoint;import java.sql.Statement;import java.sql.Struct;import java.util.LinkedList;import java.util.Map;import java.util.Properties;import java.util.concurrent.Executor;public class MyConnection implements Connection &#123; // 1.声明变量 private Connection conn ; private LinkedList&lt;Connection&gt; pool ; // 2.编写构造方法，利用多态的特性 public MyConnection(Connection conn, LinkedList&lt;Connection&gt; pool) &#123; this.conn = conn ; this.pool = pool ; &#125; /** * 3.增强后的close()方法 */ @Override public void close() throws SQLException &#123; pool.add(conn) ; &#125; /** * 重写后的PreparedStatement()方法 */ @Override public PreparedStatement prepareStatement(String sql) throws SQLException &#123; return conn.prepareStatement(sql) ; &#125; //因为太长了，此处省略一些没有实现的方法&#125; 下面是测试代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.jdbc.utils.test;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;import javax.sql.DataSource;import org.junit.Test;import com.jdbc.datasource.MyDataSource;import testjunit.com.JdbcUtils;public class MyDataSourceTest &#123; @Test public void testAddCategory() &#123; Connection conn = null ; PreparedStatement pstt = null ; // 1.创建数据库连接池对象 DataSource mds = new MyDataSource() ; try &#123; // 2.获取数据库连接 conn = mds.getConnection() ; // 3.编写SQL语句 String sql = "update category set cname = ? where cid = ?" ; // 4.创建执行SQL语句的对象 pstt = conn.prepareStatement(sql) ; // 设置参数 pstt.setString(1, "鞋靴") ; pstt.setString(2, "c007") ; // 执行更新操作并返回操作的行数 int rows = pstt.executeUpdate() ; if (rows &gt; 0) &#123; System.out.println("Update Success !") ; &#125; else &#123; System.out.println("Update failed !") ; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 调用此方法将会把连接归还到连接池中而不是直接关闭连接 JdbcUtils.release(conn, pstt, null) ; &#125; &#125;&#125; 通过上面的代码可以发现，在创建自定义数据库连接池的时候，核心的代码并不多，但是有相当多的方法需要重写，而这些方法大部分暂时还用不到，所以在实际中并不会这么做，为了更高效地创建连接池，通常会使用下面的三种方式。 C3P0 C3P0官网，要使用C3P0创建数据库连接池，需要用到相关的jar包以及配置xml文件，jar包下载地址，关于xml文件的配置官网上的文档有相关的说明，文档地址，下面是我的配置的一个简单的xml文件，内容如下： xml配置文件1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;c3p0-config&gt; &lt;default-config&gt; &lt;property name="driverClass"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql:///test?useSSL=false&amp;amp;serverTimezone=GMT%2B8&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;12345678&lt;/property&gt; &lt;property name="initialPoolSize"&gt;5&lt;/property&gt; &lt;property name="maxPoolSize"&gt;20&lt;/property&gt; &lt;/default-config&gt; &lt;named-config name="mydb"&gt; &lt;property name="driverClass"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql:///test&lt;/property&gt; &lt;property name="user"&gt;mackvord&lt;/property&gt; &lt;property name="password"&gt;12345678&lt;/property&gt; &lt;/named-config&gt; &lt;/c3p0-config&gt; 上面的xml文件包括一个默认的配置和一个自定义的配置，创建连接池的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.jdbc.utils.test;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;import org.junit.Test;import com.mchange.v2.c3p0.ComboPooledDataSource;import testjunit.com.JdbcUtils;public class C3p0Test &#123; @Test public void testAddCategory() &#123; Connection conn = null ; PreparedStatement pstt = null ; // 1.创建数据库连接池对象,不写参数加载的是默认的配置 ComboPooledDataSource cpds = new ComboPooledDataSource() ; //ComboPooledDataSource cpds = new ComboPooledDataSource("mydb") ; try &#123; // 2.获取数据库连接 conn = cpds.getConnection() ; // 3.编写SQL语句 String sql = "update category set cname = ? where cid = ?" ; // 4.创建执行SQL语句的对象 pstt = conn.prepareStatement(sql) ; // 设置参数 pstt.setString(1, "c007") ; pstt.setString(2, "影音") ; // 执行更新操作并返回操作的行数 int rows = pstt.executeUpdate() ; if (rows &gt; 0) &#123; System.out.println("Update Successful !") ; &#125; else &#123; System.out.println("Update failed !") ; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JdbcUtils.release(conn, pstt, null) ; &#125; &#125;&#125; 可以发现，使用C3P0创建连接池相比于使用原生的方法创建连接池要方便得多。 DBCPDBCP相比于C3P0可能稍逊一筹，但功能也很强大，由apache开发，dbcp2 jar包下载地址，pool2 jar包下载地址，在使用DBCP前需要先创建properties文件，所以我们可以创建一个工具类来加载资源文件。 DBCP工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.jdbc.utils;import java.io.InputStream;import java.sql.Connection;import java.util.Properties;import javax.sql.DataSource;import org.apache.commons.dbcp2.BasicDataSourceFactory;/** * DBCP数据库连接池 * 需要导入的包：commons-logging、commons-dbcp2、commons-pool2 */public class DbcpUtils &#123; // 1.声明一个DataSource对象 private static DataSource ds ; static &#123; try &#123; // 2.加载properties文件输入流 InputStream is = DbcpUtils.class.getClassLoader().getResourceAsStream("db.properties") ; // 3.加载输入流 Properties pts = new Properties() ; pts.load(is) ; // 4.创建数据源 ds = BasicDataSourceFactory.createDataSource(pts) ; &#125; catch (Exception e) &#123; throw new RuntimeException() ; &#125; &#125; /** * 获取数据源的方法 * @return */ public static DataSource getDataSource() &#123; return ds ; &#125; /** * 获取连接的方法 */ public static Connection getConnection() &#123; try &#123; return ds.getConnection() ; &#125; catch (Exception e) &#123; throw new RuntimeException() ; &#125; &#125;&#125; 下面是测试代码： DbcpTest.java12345678910111213141516171819202122232425262728293031323334353637package com.jdbc.utils.test;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;import org.junit.Test;import com.jdbc.utils.DbcpUtils;import testjunit.com.JdbcUtils;/** * 测试DBCP数据库连接池 */public class DbcpTest &#123; @Test public void testUpdateByCid() &#123; Connection conn = null ; PreparedStatement pstt = null ; try &#123; conn = DbcpUtils.getConnection() ; String sql = "update category set cname = ? where cid = ?" ; pstt = conn.prepareStatement(sql) ; pstt.setString(1, "美妆") ; pstt.setString(2, "c004") ; int rows = pstt.executeUpdate() ; if (rows &gt; 0) &#123; System.out.println("Update Successful !") ; &#125; else &#123; System.out.println("Update Failed !") ; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JdbcUtils.release(conn, pstt, null) ; &#125; &#125;&#125; DRUID druid官网，DRUID是一个开源的分布式数据存储程序。]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>C3P0</tag>
        <tag>DBCP</tag>
        <tag>DRUID</tag>
        <tag>数据库连接池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL常用操作]]></title>
    <url>%2Fdatabase%2F3773452768.html</url>
    <content type="text"><![CDATA[MySQL——世界上最流行的开源数据库！ 写在前面 MySQL官网 数据库排名 W3school SQL W3Cschool MySQL 基本操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980|---数据库操作 |---连接数据库 | |--- mysql -u 用户名 -p 密码 | |---创建数据库 | |---create database 数据库名称; | |---查看数据库 | |---show databases; | |---删除数据库 | |---drop database 数据库名称; | |---切换数据库 | |---use 数据库名称; | |---创建表 | |---create table 表名(字段名称 类型(长度) [约束],字段名称 类型(长度) [约束]) | |---查看表 | |---查看所有的数据表 | | |--show tables; | | | |---查看表结构 | |--desc 表名称; | |---删除表 | |---drop table 表名称; | |---修改表 | |---添加列 | | |---alter table 表名称 add 列名称 类型(长度) [约束]; | | | |---修改列的类型长度以及约束 | | |---alter table 表名称 modify 列名称 类型(长度) [约束]; | | | |---修改列名称 | | |---alter table 表名称 change 旧列名称 新列名称 类型(长度) [约束]; | | | |---删除列 | | |---later table 表名称 drop 列名称; | | | |---修改表名称 | | |---rename table 表名称 to 新表名称 | | | |---修改表字符集 | |---alter table 表名称 character set 字符集; | |---插入记录(insert) | |---insert into 表 (列1,列2,列3...) value(值1,值2,值3...); | |---更新记录(update) | |---update 表名称 set 字段名称=值,字段名称=值...; | |---update 表名称 set 字段名称=值,字段名称=值...where 条件; | |---删除记录 | |---delete from 表名称 [where 条件]; | |---基本查询操作 | |---select * from 表名称 [where 条件]; | |---多表查询 | |---交叉连接查询(得到的是两个表的乘积) | | |---select * from 表1,表2; | | | |---内连接查询 | | |---隐式内连接 | | | |---SELECT * FROM 表1,表2 WHERE 条件; | | | | | |---显式内连接 | | |---SELECT * FROM 表1 INNER JOIN 表2 ON 条件; | | | |---外连接查询 | |---左外连接 | | |---SELECT * FROM 表1 LEFT JOIN 表2 ON 条件; | | | |---右外连接 | |---SELECT * FROM 表1 RIGHT JOIN 表2 ON 条件; | |---子查询：一条SELECT语句的结果作为另一条SELECT语句的一部分 在代码中连接MySQL MySQL驱动包下载，以java为例，不同版本的MySQL其需要加载的驱动类(Driver)是不一样的，或者说驱动类所在的位置是不一样的，旧版的驱动类路径为com.mysql.jdbc.Driver，新版的驱动(8.0)路径为com.mysql.cj.jdbc.Driver，而且在获取数据库连接时需要指定参数serverTimezone，也就是服务器时区，通常情况下是设置为UTC或者GMT%2B8，UTC是世界标准时间，而GMT%2B8是指格林威治时间+8小时，也是中国所在时区的时间，其中的%2B表示的是转义字符+，当然，通常情况下，我们还会设置另一个参数useSSL。下面是在代码中简单模拟连接MySQL数据库的过程： 12345678910111213141516171819202122232425262728293031323334353637package my.mysql;import java.sql.Connection;import java.sql.DriverManager;public class MysqlConnection &#123; /** * mysql-connector-java-6之后的驱动为com.mysql.cj.jdbc.Driver */ private static final String DB_DRIVER = "com.mysql.cj.jdbc.Driver" ; /** * URL需要指定服务器时区以及是否使用SSL,MySQL默认的系统时间比东八区少8个小时 */ private static final String DB_URL = "jdbc:mysql://localhost:3306/test?useSSL=true&amp;serverTimezone=GMT%2B8" ; /** * USER_NAME:用户名 */ private static final String USER_NAME = "mackvord" ; /** * PASSWORD:密码 */ private static final String PASSWORD = "12345678" ; public static void main(String[] args) throws Exception &#123; // 1.加载数据库驱动程序 Class.forName(DB_DRIVER) ; // 2.连接数据库 Connection conn = DriverManager.getConnection(DB_URL, USER_NAME, PASSWORD) ; // 3.查看是否连接成功，如果连接上了，将会打印出conn对象的地址信息 System.out.println(conn) ; // 4.关闭连接 conn.close() ; &#125;&#125;]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Aplayer & Dplayer 嵌入音频和视频]]></title>
    <url>%2Faplayer-dplayer%2F547187035.html</url>
    <content type="text"><![CDATA[由于在使用Aplayer和Dplayer插件在Markdown文章中嵌入音频和视频的时候，遇到了很多细节问题，官方文档中只是给出了关键性的代码，对于小白来说，难以入手，所以决定专门用一篇文章来详细讲解Aplayer和Dplayer的使用。 写在前面文档 官方文档: https://github.com/MoePlayer/hexo-tag-aplayer 官方文档: https://github.com/MoePlayer/hexo-tag-dplayer 前端CDN加速库 Staticfile CDN BootCDN 百度静态资源公共库 建议在使用CDN加速之前先进行Ping命令测试连接速度 插入音频相比于使用HTML标签，使用插件嵌入音频可以实现更多功能而且效果也更好看，比如音乐列表，现在用的比较多的是APlayer插件，传送门。 安装 Aplayer打开git命令行，切换到站点根目录下，输入如下命令进行安装： 1npm install hexo-tag-aplayer --save 插入单曲安装完成后，在Markdown文件中的写法如下，使用这种语法插入音频有个很蛋疼的问题就是往往找不到歌词文件。所以不推荐！ 12345678910&#123;% aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %&#125;title : 曲目标题author: 曲目作者url: 音乐文件 URL 地址picture_url: (可选) 音乐对应的图片地址narrow: （可选）播放器袖珍风格autoplay: (可选) 自动播放，移动端浏览器暂时不支持此功能width:xxx: (可选) 播放器宽度 (默认: 100%)lrc:xxx: （可选）歌词文件 URL 地址&#123;% aplayer "歌曲名" "歌手名" "https://Xxx.mp3" "https://封面图.jpg" "lrc:https://歌词.lrc" %&#125; 插入音乐列表插入音乐列表有几种语法，比较常用是以下几种： 123456789101112131415161718192021222324251、&#123;% aplayerlist %&#125;&#123; .... .... .... &quot;music&quot;: [ &#123; .... , .... &#125;, &#123; .... , .... &#125; .... ]&#125;&#123;% endaplayerlist %&#125;2、&#123;% meting ... %&#125;3、&lt;div class=&quot;aplayer&quot; ... /&gt;&lt;/div&gt; 1、使用playerlist和endplayerlist标签 使用playerlist和endplayerlist标签插入音乐列表的时候，参数可以使用外链或者直接使用资源文件夹中的资源，注意两者的区别，如果直接引用引用文章资源文件夹中的文件，需要事先将所有的相关资源，包括音乐文件、歌词文件、封面图片都被放置到了与文章对应的资源文件夹中。如果相关的资源没有放置到资源文件夹中，就需要在代码中就指定相关资源的链接地址。 引用资源文件夹中的资源的写法:123456789101112131415161718192021222324252627&#123;% aplayerlist %&#125;&#123; "narrow": false, // （可选）播放器袖珍风格 "autoplay": true, // （可选) 自动播放，移动端浏览器暂时不支持此功能 "mode": "random", // （可选）曲目循环类型，有 'random'（随机播放）, 'single' (单曲播放), 'circulation' (循环播放), 'order' (列表播放)， 默认：'circulation' "showlrc": 3, // （可选）歌词显示配置项，可选项有：1,2,3 "mutex": true, // （可选）该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 "theme": "#e6d0b2", // （可选）播放器风格色彩设置，默认：#b7daff "preload": "metadata", // （可选）音乐文件预载入模式，可选项： 'none' 'metadata' 'auto', 默认: 'auto' "listmaxheight": "513px", // (可选) 该播放列表的最大长度 "music": [ &#123; "title": "CoCo", "author": "Jeff Williams", "url": "caffeine.mp3", "pic": "caffeine.jpeg", "lrc": "caffeine.txt" &#125;, &#123; "title": "アイロニ", "author": "鹿乃", "url": "irony.mp3", "pic": "irony.jpg" &#125; ]&#125;&#123;% endaplayerlist %&#125; 由于参数比较多，这里就不一一列出来了，想要了解更多信息，请参考官方文档 引用资源文件夹资源前的准备工作如果使用了资源文件夹，那么我们就要事先将音乐文件、歌词文件、封面图片保存到资源文件夹中，以网易云音乐为例，如果要下载歌词文件和封面图片比较麻烦，具体的做法如下： 获取MP3外链首先打开网易云音乐，搜索你想要获取外链的音乐，点击封面图片下面的分享，选择复制链接，得到类似下面的链接，观察链接可以发现song?id=后面的值477834320就是歌曲的ID值 1http://music.163.com/#/song?id=477834320&amp;userid=368032536 接下来将id值替换掉下面的代码中XXXX就可以得到MP3外链了 http://music.163.com/song/media/outer/url?id=XXXX.mp3 下载歌词文件首先打开网页版的网易云音乐，搜索你想要下载的音乐，点击进入单曲界面，复制浏览器搜索栏中id值，也就是类似http://music.163.com/#/song?id=xxxxxxxx中的xxxxxxxx，然后将复制的id值添加到链接http://music.163.com/api/song/media?id=XXXXXXXX的末尾，替换掉XXXXXXXX，将新的链接贴到浏览器搜索栏中即可看到歌词文件，类似于下图： 复制歌词信息到一个新的word文档中，去掉头部第一个[00:xx.xx]前的信息，类似于{&quot;songStatus&quot;:1,&quot;lyricVersion&quot;:13,&quot;lyric&quot;:&quot;，并且删除掉尾部类似于&quot;,&quot;code&quot;:200}的信息，然后在word文档中选择替换，将所有的\n替换为段落标记： 替换完成后保存退出，重命名文件并将文件后缀改为lrc即可，最后将歌词文件放到资源文件夹中。 如果发现歌词出现乱码，在保存的时候选择另存为，然后点击底部的工具选项，选择Web选项，将编码设置为Unicode(UTF-8)即可。 获取封面外链手机端下载: 封面的下载可以使用手机网易云音乐客户端，搜索想要下载的音乐，点击封面图片即可下载，然后将图片发送到电脑端即可。 电脑端下载: 与下载歌词类似，打开网页版的网易云音乐，搜索你想要下载的音乐，点击进入单曲界面，按F12打开浏览器调试工具，以谷歌浏览器为例，点击调试界面左上角的小箭头，然后将光标定位到封面图片上就可以定位出封面图片所在的标签: 复制图片链接，并去掉?param=130y130便可以得到封面图片的链接地址: 1http://p1.music.126.net/Eg4cy0_HIF2nrX2gMCsWkQ==/17967119509636556.jpg 引用资源文件插入音乐列表源码示例1234567891011121314151617181920212223242526272829303132333435&#123;% aplayerlist %&#125;&#123; "narrow": false, "autoplay": false, "mode": "random", "showlrc": 3, "mutex": true, "theme": "#e6d0b2", "preload": "metadata", "listmaxheight": "513px", "music": [ &#123; "title": "I Do", "author": "911", "url": "911 - I Do.mp3", "pic": "I Do.jpg", "lrc": "I Do.lrc" ## 注意这里是没有逗号的，前面的都有逗号 &#125;, &#123; "title": "アイロニ", "author": "majiko", "url": "まじ娘 - アイロニ.mp3", "pic": "アイロニ.jpg", "lrc": "アイロニ.txt" ## 注意这里也是没有逗号的，前面的都有逗号 &#125;, &#123; "title": "云烟成雨", "author": "房东的猫", "url": "云烟成雨.mp3", "pic": "云烟成雨.jpg", "lrc": "云烟成雨.txt" ## 注意这里也是没有逗号的，前面的都有逗号 &#125; ## 注意这里是没有逗号的，除了最后一对花括号，中括号 [] 里面的每一对花括号 &#123;&#125; 后都有逗号 ]&#125;&#123;% endaplayerlist %&#125; 注意上面的代码中的逗号，之前由于大意，漏写了逗号，愣是懵逼了半天没发现哪里错了，切记切记！！，由于这种方法比较影响部署的速度，所以已经被我弃用了，想要看效果的话，请继续往下看！！ 使用外链插入音乐列表使用aplayerlist标签使用外链插入音乐列表，相比于引用资源文件夹中的文件，可以减少部署到服务器的时间，因为如果保存到资源文件夹中音频文件越多，必定会降低部署的速度。当然，使用外链的话，需要自行查找相关链接，或者可以使用七牛之类的对象存储生成外链。 使用外链插入音乐列表:123456789101112131415161718192021&#123;% aplayerlist %&#125;&#123; "narrow": false, "autoplay": false, "mode": "random", "music": [ &#123; "title": "League of Legends Epic Dubstep(LOL Remix)", "author": "ThimLife", "url": "http://music.163.com/song/media/outer/url?id=32341324.mp3", "pic": "http://p1.music.126.net/cz-wpFeAxsRJfl-cdmnM-Q==/3430476280185179.jpg", &#125;, &#123; "title": "英雄联盟 - Edge of Infinity", "author": "英雄联盟", "url": "http://music.163.com/song/media/outer/url?id=477834320.mp3", "pic": "http://p1.music.126.net/kh9X5Ov1Qg9x97ZX_Pw1Rw==/109951162926291073.jpg", &#125; ]&#125;&#123;% endaplayerlist %&#125; 由于在同一个页面插入多个音乐列表会有问题，所以此处效果就不展示了，具体的效果与下面的音乐列表类似 使用 &#60;div class=”aplayer” … /&#62;&#60;div&#62;标签 官方文档 使用示例:1&lt;div class="aplayer" data-id="972904675" data-server="netease" data-type="playlist" data-autoplay="false" "data-mode:circulation"&gt;&lt;/div&gt; 插入网易云音乐歌单的效果: 强烈推荐这种方法在Markdown文章中插入音乐列表，代码简洁高效，跨平台 关于 Aplayer 对 MetingJS 的支持在APlayer官方文档中有对MetingJS的说明：MetingJS 是基于Meting API 的 APlayer 衍生播放器，支持多平台，包括netease(网易云音乐), tencent(QQ音乐), kugou(酷狗音乐), xiami(小米音乐), baidu(百度音乐)等。 如果想要在文章使用MetingJS，需要在主题配置文件(_config.yml)中，设置： 12aplayer: meting: true 在实际的使用中发现，在进行了上述的设置之后，依然无法使用{% meting ... %}插入音频文件，在执行hexo g的时候就会报错: 错误信息:12345678INFO Start processingError: [hexo-tag-aplayer] Meting support is disabled, cannot resolve the meting tags properly. at throwError (E:\Node_JS_Hexo\node_modules\hexo-tag-aplayer\common\util.js:18:9) at Object.&lt;anonymous&gt; (E:\Node_JS_Hexo\node_modules\hexo-tag-aplayer\index.js:160:28) at NunjucksTag._run (E:\Node_JS_Hexo\node_modules\hexo\lib\extend\tag.js:120:18) at NunjucksTag.run (E:\Node_JS_Hexo\node_modules\hexo\lib\extend\tag.js:116:15) at Template.root [as rootRenderFunc] (eval at _compile (E:\Node_JS_Hexo\node_modules\nunjucks\src\environment.js:617:18), &lt;anonymous&gt;:29:66) ...... 注：上述问题已解决，一次无意间发现文章中一个行内代码块标签( ` ` )没有显示内容，通过查看Markdown文档中相应的位置，发现不能正常显示的标签是：&#123;&#37; meting … &#37;&#125; ，不知道为什么使用了 将其标记为行内代码块的时候，在解析的时候依然无法通过，之后使用Next自带的label标签进行标记，解析通过了，之后就能正常渲染部署了 在实际的使用过程中发现，如果提示meting标签无法被识别，那么有可能是Markdown书写错误，还有一种可能就是Meting.min.js没有被加载到header中，结合官方文档最后对 重复载入 Aplayer.js 资源脚本问题 的说明，打开谷歌调试工具，发现在&lt;header&gt;标签里面，只有APlayer.js(APlayer.min.js)脚本被加载进去了，Meting.js(Meting.min.js)并没有被加载进去，为了解决这个问题，需要在配置文件中手动加入APlayer.js和Meting.js，并且关闭aplayer插件的自动插入脚本的功能 关闭自动插入脚本的功能: 配置文件:-\themes\next\_config.yml123aplayer: meting: true ## 启用meting asset_inject: false ## 关闭自动插入脚本的功能 添加 APlayer.js 和 Meting.js 由于本人使用的是Pisces主题，所以要修改的文件是~\themes\next\layout\_custom\header.swig，在header.swig中添加下面的代码，其他主题请自行修改相应的文件。 配置文件路径:-\themes\next\layout\_custom\header.swig12345&lt;link href="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.css" rel="stylesheet"&gt;&lt;script src="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"&gt;&lt;/script&gt;&lt;link href="https://cdn.bootcss.com/dplayer/1.22.2/DPlayer.min.css" rel="stylesheet"&gt;&lt;script src="https://cdn.bootcss.com/dplayer/1.22.2/DPlayer.min.js"&gt;&lt;/script&gt; 代码中的src指的是引用 APlayer.min.js 或 Meting.min.js 外部 CDN 地址 关于CDN加速，在文章开头已经给出了几个速度比较快的加速库地址，进去搜索你想要的js外链即可，Meting.min.js使用的是官方提供的CDNhttps://github.com/metowolf/MetingJS 接下来修改~\themes\next\layout\_layout.swig路径下的layout.swig文件，将上面的外部CDN应用添加到HTML页面的&lt;header&gt;标签中，修改如下： 12345678910111213141516&lt;!DOCTYPE html&gt;&#123;% set html_class = 'theme-next ' + theme.scheme %&#125;&#123;% if theme.motion.enable %&#125; &#123;% set html_class = html_class + ' use-motion' %&#125;&#123;% endif %&#125;&lt;html class="&#123;&#123; html_class | lower &#125;&#125;" lang="&#123;&#123; config.language &#125;&#125;"&gt;&lt;head&gt; &#123;% include '_partials/head.swig' %&#125; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt; &#123;% include '_third-party/analytics/index.swig' %&#125;+ &#123;% include '_custom/header.swig' %&#125; ## 添加这一句即可&lt;/head&gt;&lt;body itemscope itemtype="http://schema.org/WebPage" lang="&#123;&#123; page.lang || page.language || config.language &#125;&#125;"&gt; 关于自定义aplayer配置: 配置文件路径:-\themes\next\_config.yml12345678910aplayer: script_dir: some/place # Public 目录下脚本目录路径，默认: 'assets/js' style_dir: some/place # Public 目录下样式目录路径，默认: 'assets/css' cdn: http://xxx/aplayer.min.js # 引用 APlayer.js 外部 CDN 地址 (默认不开启) style_cdn: http://xxx/aplayer.min.css # 引用 APlayer.css 外部 CDN 地址 (默认不开启) meting: true # MetingJS 支持 meting_api: http://xxx/api.php # 自定义 Meting API 地址 meting_cdn: http://xxx/Meing.min.js # 引用 Meting.js 外部 CDN 地址 (默认不开启) asset_inject: true # 自动插入 Aplayer.js 与 Meting.js 资源脚本, 默认开启 externalLink: http://xxx/aplayer.min.js # 老版本参数，功能与参数 cdn 相同 1&#123;% meting &quot;972904675&quot; &quot;netease&quot; &quot;playlist&quot; &quot;autoplay&quot; &quot;mutex:false&quot; &quot;listmaxheight:340px&quot; &quot;preload:none&quot; &quot;theme:#ad7a86&quot;%&#125; 使用Meting标签嵌入音乐列表: 有BUG，调试中！！！ 插入视频 参考文档: https://dplayer.js.org/#/zh-Hans/ 代码示例12Demo:&#123;% dplayer "url=https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.mp4" "pic=https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.png" "loop=false" "theme=#FADFA3" "autoplay=false" "token=tokendemo" "screenshot=true" %&#125; Demo效果: (function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","video":{"url":"https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.mp4","pic":"https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.jpg"},"danmaku":{"id":"9E2E3368B56CDBB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo","addition":["https://dplayer.daoapp.io/bilibili?aid=4157142"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 不管是嵌入音频还是视频，如果产生了下面的错误，说明js脚本并没有插入到&lt;header&gt;标签内，导致dplayer标签无法被识别，可以尝试重新安装aplayer或者dplayer看看问题是否解决。 123456789$ hexo gINFO Start processingFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: unknown block tag: dplayer ## 未知块标签:xxx at Object._prettifyError (E:\Node_JS_Hexo\node_modules\nunjucks\src\lib.js:35:11) at Template.render (E:\Node_JS_Hexo\node_modules\nunjucks\src\environment.js:526:21) at Environment.renderString (E:\Node_JS_Hexo\node_modules\nunjucks\src\environment.js:364:17) at Promise (E:\Node_JS_Hexo\node_modules\hexo\lib\extend\tag.js:66:9) at Promise._execute (E:\Node_JS_Hexo\node_modules\bluebird\js\release\debuggability.js:303:9) 关于视频或音频链接的问题根据我自己的实践经验发现，无论是插入视频还是音频，如何找到一个可使用的链接是一个很头疼的问题，很多视频网站给出的分享链接不是视频的真实链接地址，这就导致了使用这些链接嵌入视频或者音频的时候，根本就无法正常播放，有些时候即使使用第三方工具，比如浏览器的调试工具获取的链接也无法使用。]]></content>
      <categories>
        <category>aplayer_dplayer</category>
      </categories>
      <tags>
        <tag>aplayer</tag>
        <tag>dplayer</tag>
        <tag>音乐</tag>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Css加载失败 排版混乱]]></title>
    <url>%2Fgithub%2F3916105637.html</url>
    <content type="text"><![CDATA[一般情况下，访问github是不需要翻墙的，只不过访问速度会稍微有点慢，如果某一天你发现访问github的时候，网页排版错误，只有文字没有样式，那很有可能是因为特殊时期被墙了 解决办法第一步: 以window用户为例，首先打开命令行工具，输入nslookup github.com，下面会显示出github的服务器列表： 12345非权威应答:名称: github.comAddresses: 13.250.177.223 52.74.223.119 13.229.188.59 第二步: 修改hosts文件，文件所在位置：C:\Windows\System32\drivers\etc，将上面显示的github服务器列表添加到hosts文件后面即可，例如： 1234# github13.250.117.223 github52.74.223.119 github13.229.188.59 github 注意:如果编辑完后无法保存，提示拒绝访问，那么就要修改hosts文件的访问权限，具体的做法：右键hosts文件，选择属性，再选择安全，选择你当前电脑的用户，点击编辑，将修改和写入的权限钩上即可，最后点击保存。如果电脑安装了的360，保存的时候会报错，不用理会，允许操作就行了。完了之后就可以正常访问github了。]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>css</tag>
        <tag>网页排版混乱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VLC + Swing制作简易视频播放器]]></title>
    <url>%2Fapplication%2F787285664.html</url>
    <content type="text"><![CDATA[利用VLC制作简易的视频播放器 写在前面本次视频播放器的制作需要准备四样东西：1、VLC播放器；2、VLC扩展库，3、Apache log4j，4、WindowBuilder插件。前两个是必须的，WindowBuilder插件是为方便开发而使用的，如果有大佬喜欢手写图形界面也是没有问题的。关于插件的安装这里不说了，比较简单，下面直接进入主题。 安装VLC播放器&emsp;&emsp;链接上面已经给出，根据自己的电脑直接下载相应的版本即可，例如我的电脑是windows 64位的，则选择windows 64bit 下载完成直接安装即可，注意记住安装路径，后面会用到。 安装VLC扩展库&emsp;&emsp;点击打开上面的VLC扩展库链接地址，或者直接点击这里传送门，找到vlcj-3.10.1 distribution (zip)点击下载，下载完成后解压缩。 下载日志库log4j&emsp;&emsp;由于在下面写代码的过程中会出现一个错误，这个错误需要通过导入log4j-1.2.17.jar包解决，所以在此先将其下载好，当然这里使用的是1.2X版本，你可以下载最新的2.X版本，这应该是没有影响的。下载链接 创建工程以及加载VLC库创建工程很简单，关键是加载VLC库，要在代码中加载VLC库，需要先在工程目录中导入所需要的jar包，包括 jna-4.1.0.jarvlcj-3.10.1.jarlog4j-1.2.17.jarslf4j-log4j12-1.7.25.jarslf4j-api-1.7.10.jar 之前由于没有导入log4j-1.2.17.jar或者slf4j-log4j12-1.7.25.jar，因此在加载VLC库文件的时候会出现各种谜一样的错误，类似于： 1234错误：log4j:WARN No appenders could be found for logger (com.mackvord.videoplayer.main.Main).log4j:WARN Please initialize the log4j system properly.log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info. 网上的解决办法也是五花八门，自己也摸索着找到了解决的方法： 先在在项目中导入log4j-1.2.17.jar和slf4j-log4j12-1.7.25.jar两个包，添加完后需要在src目录下添加一个log.properties文件指定日志信息的存放地址，log.properties里的内容可以自定义，下面是我的log.properties文件中的内容： 123456789101112# Root logger optionlog4j.rootLogger=INFO, logg# Redirect log messages to a log file, support file rolling.log4j.appender.logg=org.apache.log4j.RollingFileAppenderlog4j.appender.logg.File=F://MyPlayer//logs//log.loglog4j.appender.logg.Append = truelog4j.appender.logg.Threshold = DEBUG log4j.appender.logg.MaxFileSize=5MBlog4j.appender.logg.MaxBackupIndex=3log4j.appender.logg.layout=org.apache.log4j.PatternLayoutlog4j.appender.logg.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %c&#123;1&#125;:%L - %m%n 还有一个迷之错误就是： 123456789101112131415java.lang.RuntimeException: Failed to initialise libvlc.This is most often caused either by an invalid vlc option being passed when creating a MediaPlayerFactory or by libvlc being unable to locate the required plugins.If libvlc is unable to locate the required plugins the instructions below may help:In the text below &lt;libvlc-path&gt; represents the name of the directory containing &quot;libvlc.dylib&quot; and &quot;libvlccore.dylib&quot; and &lt;plugins-path&gt; represents the name of the directory containing the vlc plugins...For libvlc to function correctly the vlc plugins must be available, there are a number of different ways to achieve this: 1. Make sure the plugins are installed in the &quot;&lt;libvlc-path&gt;/vlc/plugins&quot; directory, this should be the case with a normal vlc installation. 2. Set the VLC_PLUGIN_PATH operating system environment variable to point to &quot;&lt;plugins-path&gt;&quot;.More information may be available in the log, specify -Dvlcj.log=DEBUG on the command-line when starting your application. 这个问题网上有不少人遇到过，但给出解决办法的却没几个，下面是我的解决办法： windows下解决的办法：在系统的环境变量中添加一条记录VLC_PLUGIN_PATH指定路径：VLC安装目录下的plugins目录，例如：F:\MyPlayer\VLC\plugins，添加完环境属性后重启电脑，再次执行程序便可正常运行。 加载VLC库文件的核心代码1234567891011121314151617181920public class PlayMain &#123; // 定义一个常量来保存本地库的搜索路径 // 不同的系统，库文件的名称不一样，在windows系统中，用于搜索路径的目录必须是包含libvic和libviccore共享对象的目录 // 共享对象是指: Linux上以.so结束的文件或者Windows上以.dll结束的文件 private static final String NATIVE_LIBRARY_SEARCH_PATH = "F:\\MyPlayer\\VLC"; static MainWindow frame ; public static void main(String[] args) &#123; // 判断当前主机是否是windows if (RuntimeUtil.isWindows()) &#123; // 显式设置库路径 NativeLibrary.addSearchPath(RuntimeUtil.getLibVlcLibraryName(), NATIVE_LIBRARY_SEARCH_PATH) ; &#125; else if (RuntimeUtil.isMac()) &#123; // 判断当前主机是否是MacOS NativeLibrary.addSearchPath(RuntimeUtil.getLibVlcLibraryName() , "/Application/VLC.app/Contens/MacOS/lib") ; &#125; // 加载VLC播放器的系统库 Native.loadLibrary(RuntimeUtil.getLibVlcLibraryName(), LibVlc.class) ; &#125;&#125; 创建界面整个界面都是在windowbuilder中进行创建，所以这一部分比较简单，界面的代码如下： 图形界面代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.mackvord.videoplayer.views;import java.awt.BorderLayout;import javax.swing.JFrame;import javax.swing.JPanel;import javax.swing.border.EmptyBorder;import com.mackvord.videoplayer.main.PlayMain;import uk.co.caprica.vlcj.component.EmbeddedMediaPlayerComponent;import uk.co.caprica.vlcj.player.embedded.EmbeddedMediaPlayer;import javax.swing.JButton;import java.awt.event.ActionListener;import java.awt.event.ActionEvent;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import javax.swing.JProgressBar;import javax.swing.JMenuBar;import javax.swing.JMenu;import javax.swing.JMenuItem;import javax.swing.JSlider;import javax.swing.event.ChangeListener;import javax.swing.event.ChangeEvent;import java.awt.Toolkit;public class MainWindow extends JFrame &#123; /** * */ private static final long serialVersionUID = 1L; private JPanel contentPane ; EmbeddedMediaPlayerComponent playerComponent ; // 定义一个播放器界面 private JPanel panel; private JButton btnNewButton; private JButton btnNewButton_1; private JButton btnStop; private JPanel controlPanel; private JProgressBar progress; private JMenuBar menuBar; private JMenu mnFile; private JMenuItem mntmOpen; private JMenuItem mntmOpenSubtitle; private JMenuItem mntmExit; private JSlider slider; /** * Launch the application. */ public static void main(String[] args) &#123; &#125; /** * Create the frame. */ public MainWindow() &#123; setIconImage(Toolkit.getDefaultToolkit().getImage(MainWindow.class.getResource("/imageIcon/wallls.com_120503.jpg"))); setTitle("MyPlayer"); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setBounds(100, 100, 614, 456); menuBar = new JMenuBar(); setJMenuBar(menuBar); mnFile = new JMenu("File"); menuBar.add(mnFile); mntmOpen = new JMenuItem("Open Video..."); mnFile.add(mntmOpen); mntmOpenSubtitle = new JMenuItem("Open Subtitle..."); mnFile.add(mntmOpenSubtitle); mntmExit = new JMenuItem("Exit"); mnFile.add(mntmExit); contentPane = new JPanel(); contentPane.setBorder(new EmptyBorder(5, 5, 5, 5)); contentPane.setLayout(new BorderLayout(0, 0)); setContentPane(contentPane); JPanel videopanel = new JPanel(); contentPane.add(videopanel, BorderLayout.CENTER); videopanel.setLayout(new BorderLayout(0, 0)); playerComponent = new EmbeddedMediaPlayerComponent() ; videopanel.add(playerComponent) ; panel = new JPanel(); videopanel.add(panel, BorderLayout.SOUTH); panel.setLayout(new BorderLayout(0, 0)); controlPanel = new JPanel(); panel.add(controlPanel, BorderLayout.CENTER); btnStop = new JButton("Stop"); controlPanel.add(btnStop); btnNewButton = new JButton("Play"); controlPanel.add(btnNewButton); btnNewButton_1 = new JButton("Pause"); controlPanel.add(btnNewButton_1); slider = new JSlider(); slider.setValue(100); slider.setMaximum(120); controlPanel.add(slider); progress = new JProgressBar(); progress.setStringPainted(true); panel.add(progress, BorderLayout.NORTH); &#125; public EmbeddedMediaPlayer getMediaPlayer() &#123; return playerComponent.getMediaPlayer() ; &#125; public JProgressBar getProgressBar() &#123; return progress ; &#125; &#125; 添加监听器事件监听代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263mntmOpen.addActionListener(new ActionListener() &#123; @Overridepublic void actionPerformed(ActionEvent e) &#123; PlayMain.openVideo() ; &#125;&#125;); mntmOpenSubtitle.addActionListener(new ActionListener() &#123; @Overridepublic void actionPerformed(ActionEvent e) &#123; PlayMain.openSubtitle() ; &#125;&#125;); mntmExit.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; PlayMain.exit() ; &#125;&#125;);slider.addChangeListener(new ChangeListener() &#123; public void stateChanged(ChangeEvent e) &#123; PlayMain.setVol(slider.getValue()) ; &#125;&#125;);progress.addMouseListener(new MouseAdapter() &#123; @Override public void mouseClicked(MouseEvent e) &#123; int x = e.getX() ; PlayMain.jumpTo((float)x/progress.getWidth()); &#125;&#125;);btnNewButton_1.addMouseListener(new MouseAdapter() &#123; @Override public void mouseClicked(MouseEvent e) &#123; PlayMain.pause() ; &#125;&#125;);btnNewButton.addMouseListener(new MouseAdapter() &#123; @Override public void mouseClicked(MouseEvent e) &#123; PlayMain.play() ; // 调用PlayMain类中的play()方法 &#125;&#125;);btnNewButton.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; &#125;&#125;);btnStop.addMouseListener(new MouseAdapter() &#123; @Override public void mouseClicked(MouseEvent e) &#123; PlayMain.stop() ; &#125;&#125;); 事件处理方法由于时间的关系，只实现了一些基本的功能，包括播放、暂停、停止、音量调节、文件的选择以及字幕文件的选择等。界面的创建以及事件监听在MainWindow类中实现，而事件的处理交由PlayMain类处理。并且PlayMain类负责界面的初始化。 播放事件1234// 播放的方法public static void play() &#123; frame.getMediaPlayer().play() ;&#125; 暂停事件1234// 暂停的方法public static void pause() &#123; frame.getMediaPlayer().pause() ;&#125; 停止事件1234// 停止的方法public static void stop() &#123; frame.getMediaPlayer().stop() ;&#125; 音量调节1234// 设置音量public static void setVol(int v) &#123; frame.getMediaPlayer().setVolume(v) ;&#125; 进度条调节播放进度1234// 进度条跳转的方法public static void jumpTo(float to) &#123; frame.getMediaPlayer().setTime((long)(to*frame.getMediaPlayer().getLength()));&#125; 选择视频文件123456789// 打开文件public static void openVideo() &#123; JFileChooser chooser = new JFileChooser() ; int v = chooser.showOpenDialog(null) ; if (v == JFileChooser.APPROVE_OPTION) &#123; File file = chooser.getSelectedFile() ; frame.getMediaPlayer().playMedia(file.getAbsolutePath()) ; &#125;&#125; 选择字幕文件123456789// 选择字幕文件public static void openSubtitle() &#123; JFileChooser chooser = new JFileChooser() ; int v = chooser.showOpenDialog(null) ; if (v == JFileChooser.APPROVE_OPTION) &#123; File file = chooser.getSelectedFile() ; frame.getMediaPlayer().setSubTitleFile(file) ; &#125;&#125; 退出时的处理12345// 退出public static void exit() &#123; frame.getMediaPlayer().release() ; // 释放播放器资源 System.exit(0) ;&#125; 完整的代码PlayMain.java: PlayMain.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package com.mackvord.videoplayer.main;import java.awt.EventQueue;import java.io.File;import javax.swing.JFileChooser;import javax.swing.SwingWorker;import com.mackvord.videoplayer.views.MainWindow;import com.sun.jna.Native;import com.sun.jna.NativeLibrary;import uk.co.caprica.vlcj.binding.LibVlc;import uk.co.caprica.vlcj.runtime.RuntimeUtil;public class PlayMain &#123; // 定义一个常量来保存本地库的搜索路径 // 不同的系统，库文件的名称不一样，在windows系统中，用于搜索路径的目录必须是包含libvic和libviccore共享对象的目录 // 共享对象是指: Linux上以.so结束的文件或者Windows上以.dll结束的文件 private static final String NATIVE_LIBRARY_SEARCH_PATH = "F:\\MyPlayer\\VLC"; static MainWindow frame ; public static void main(String[] args) &#123; // 判断当前主机是否是windows if (RuntimeUtil.isWindows()) &#123; // 显式设置库路径 NativeLibrary.addSearchPath(RuntimeUtil.getLibVlcLibraryName(), NATIVE_LIBRARY_SEARCH_PATH) ; &#125; else if (RuntimeUtil.isMac()) &#123; // 判断当前主机是否是MacOS NativeLibrary.addSearchPath(RuntimeUtil.getLibVlcLibraryName() , "/Application/VLC.app/Contens/MacOS/lib") ; &#125; // 加载VLC播放器的系统库 Native.loadLibrary(RuntimeUtil.getLibVlcLibraryName(), LibVlc.class) ; EventQueue.invokeLater(new Runnable() &#123; public void run() &#123; try &#123; frame = new MainWindow(); frame.setVisible(true); String options[] = &#123;"--subsdec-encoding=UTF-8"&#125; ; // 指定字幕的解码方式 //frame.getMediaPlayer().playMedia("E:\\CloudMusic\\MV\\我是江小白.mp4", options) ; frame.getMediaPlayer().prepareMedia("E:\\CloudMusic\\MV\\我是江小白.mp4", options) ; new SwingWorker&lt;String, Integer&gt;() &#123; @Override protected String doInBackground() throws Exception &#123; while (true) &#123; long total = frame.getMediaPlayer().getLength() ; long curr = frame.getMediaPlayer().getTime() ; float percent = (float)curr / total ; // 此处不要使用括号扩住curr/total publish((int)(percent*100)) ; Thread.sleep(100) ; // 每一百毫秒刷新一次 &#125; &#125; protected void process(java.util.List&lt;Integer&gt; chunks) &#123; for (int v : chunks) &#123; frame.getProgressBar().setValue(v) ; &#125; &#125;; &#125;.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; // 播放的方法 public static void play() &#123; frame.getMediaPlayer().play() ; &#125; // 暂停的方法 public static void pause() &#123; frame.getMediaPlayer().pause() ; &#125; // 停止的方法 public static void stop() &#123; frame.getMediaPlayer().stop() ; &#125; // 进度条跳转的方法 public static void jumpTo(float to) &#123; frame.getMediaPlayer().setTime((long)(to*frame.getMediaPlayer().getLength())); &#125; // 设置音量 public static void setVol(int v) &#123; frame.getMediaPlayer().setVolume(v) ; &#125; // 打开文件 public static void openVideo() &#123; JFileChooser chooser = new JFileChooser() ; int v = chooser.showOpenDialog(null) ; if (v == JFileChooser.APPROVE_OPTION) &#123; File file = chooser.getSelectedFile() ; frame.getMediaPlayer().playMedia(file.getAbsolutePath()) ; &#125; &#125; // 选择字幕文件 public static void openSubtitle() &#123; JFileChooser chooser = new JFileChooser() ; int v = chooser.showOpenDialog(null) ; if (v == JFileChooser.APPROVE_OPTION) &#123; File file = chooser.getSelectedFile() ; frame.getMediaPlayer().setSubTitleFile(file) ; &#125; &#125; // 退出 public static void exit() &#123; frame.getMediaPlayer().release() ; // 释放播放器资源 System.exit(0) ; &#125;&#125; MainWindow.java: MianWindow.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182package com.mackvord.videoplayer.views;import java.awt.BorderLayout;import javax.swing.JFrame;import javax.swing.JPanel;import javax.swing.border.EmptyBorder;import com.mackvord.videoplayer.main.PlayMain;import uk.co.caprica.vlcj.component.EmbeddedMediaPlayerComponent;import uk.co.caprica.vlcj.player.embedded.EmbeddedMediaPlayer;import javax.swing.JButton;import java.awt.event.ActionListener;import java.awt.event.ActionEvent;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import javax.swing.JProgressBar;import javax.swing.JMenuBar;import javax.swing.JMenu;import javax.swing.JMenuItem;import javax.swing.JSlider;import javax.swing.event.ChangeListener;import javax.swing.event.ChangeEvent;import java.awt.Toolkit;public class MainWindow extends JFrame &#123; /** * */ private static final long serialVersionUID = 1L; private JPanel contentPane ; EmbeddedMediaPlayerComponent playerComponent ; // 定义一个播放器界面 private JPanel panel; private JButton btnNewButton; private JButton btnNewButton_1; private JButton btnStop; private JPanel controlPanel; private JProgressBar progress; private JMenuBar menuBar; private JMenu mnFile; private JMenuItem mntmOpen; private JMenuItem mntmOpenSubtitle; private JMenuItem mntmExit; private JSlider slider; /** * Launch the application. */ public static void main(String[] args) &#123; &#125; /** * Create the frame. */ public MainWindow() &#123; setIconImage(Toolkit.getDefaultToolkit().getImage(MainWindow.class.getResource("/imageIcon/wallls.com_120503.jpg"))); setTitle("MyPlayer"); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setBounds(100, 100, 614, 456); menuBar = new JMenuBar(); setJMenuBar(menuBar); mnFile = new JMenu("File"); menuBar.add(mnFile); mntmOpen = new JMenuItem("Open Video..."); mnFile.add(mntmOpen); mntmOpenSubtitle = new JMenuItem("Open Subtitle..."); mnFile.add(mntmOpenSubtitle); mntmExit = new JMenuItem("Exit"); mnFile.add(mntmExit); mntmOpen.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; PlayMain.openVideo() ; &#125; &#125;); mntmOpenSubtitle.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; PlayMain.openSubtitle() ; &#125; &#125;); mntmExit.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; PlayMain.exit() ; &#125; &#125;); contentPane = new JPanel(); contentPane.setBorder(new EmptyBorder(5, 5, 5, 5)); contentPane.setLayout(new BorderLayout(0, 0)); setContentPane(contentPane); JPanel videopanel = new JPanel(); contentPane.add(videopanel, BorderLayout.CENTER); videopanel.setLayout(new BorderLayout(0, 0)); playerComponent = new EmbeddedMediaPlayerComponent() ; videopanel.add(playerComponent) ; panel = new JPanel(); videopanel.add(panel, BorderLayout.SOUTH); panel.setLayout(new BorderLayout(0, 0)); controlPanel = new JPanel(); panel.add(controlPanel, BorderLayout.CENTER); btnStop = new JButton("Stop"); controlPanel.add(btnStop); btnNewButton = new JButton("Play"); controlPanel.add(btnNewButton); btnNewButton_1 = new JButton("Pause"); controlPanel.add(btnNewButton_1); slider = new JSlider(); slider.setValue(100); slider.setMaximum(120); slider.addChangeListener(new ChangeListener() &#123; public void stateChanged(ChangeEvent e) &#123; PlayMain.setVol(slider.getValue()) ; &#125; &#125;); controlPanel.add(slider); progress = new JProgressBar(); progress.addMouseListener(new MouseAdapter() &#123; @Override public void mouseClicked(MouseEvent e) &#123; int x = e.getX() ; PlayMain.jumpTo((float)x/progress.getWidth()); &#125; &#125;); progress.setStringPainted(true); panel.add(progress, BorderLayout.NORTH); btnNewButton_1.addMouseListener(new MouseAdapter() &#123; @Override public void mouseClicked(MouseEvent e) &#123; PlayMain.pause() ; &#125; &#125;); btnNewButton.addMouseListener(new MouseAdapter() &#123; @Override public void mouseClicked(MouseEvent e) &#123; PlayMain.play() ; // 调用PlayMain类中的play()方法 &#125; &#125;); btnNewButton.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; &#125; &#125;); btnStop.addMouseListener(new MouseAdapter() &#123; @Override public void mouseClicked(MouseEvent e) &#123; PlayMain.stop() ; &#125; &#125;); &#125; public EmbeddedMediaPlayer getMediaPlayer() &#123; return playerComponent.getMediaPlayer() ; &#125; public JProgressBar getProgressBar() &#123; return progress ; &#125; &#125; 效果]]></content>
      <categories>
        <category>application</category>
      </categories>
      <tags>
        <tag>Swing</tag>
        <tag>VLC</tag>
        <tag>视频播放器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode]]></title>
    <url>%2Falgorithms%2F1620505557.html</url>
    <content type="text"><![CDATA[“程序=算法+数据结构”这句话相信每一个开发者都听过，好的算法能够使程序更更高效地处理各种问题 两数之和题目难度：简单题目描述：给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例： 给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解法1： 12345678910111213141516171819202122public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; for (int i = 0 ; i &lt; nums.length - 1 ; i++) &#123; for (int j = i + 1 ; j &lt; nums.length ; j++) &#123; if (nums[i] + nums[j] == target) &#123; return new int[]&#123;i, j&#125; ; &#125; &#125; &#125; return new int[0] ; &#125; public static void main(String[] args) &#123; Solution s = new Solution() ; int[] nums = new int[]&#123;2,7,11,15&#125; ; int target = 9 ; int[] toArray = s.twoSum(nums, target) ; for(int x : toArray) &#123; System.out.println(x) ; &#125; &#125;&#125; 反转整数题目难度：简单题目描述：给定一个 32 位有符号整数，将整数中的数字进行反转。 示例1： 输入: 123输出: 321 示例2： 输入: -123输出: -321 示例3： 输入: 120输出: 21 注意： 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。 解法1： 123456789101112131415161718192021public class Solution &#123; public int reverse(int x) &#123; int result = 0; while (x != 0) &#123; int temp = result * 10 + x % 10 ; x = x / 10 ; if (temp / 10 != result) &#123; result = 0 ; break ; &#125; result = temp; &#125; return result; &#125; public static void main(String[] args) &#123; Solution s = new Solution() ; int x = 123 ; System.out.println(s.reverse(x)) ; &#125;&#125; 删除排序数组中的重复项题目难度：简单题目描述：给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例1： 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例2： 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 说明： 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解法1： 12345678910111213141516171819public class Solution &#123; int a = 0 ; int count = 1 ; public int removeDuplicates(int[] nums) &#123; for(int i = 0 ; i &lt; nums.length ; i++)&#123; if (nums[a] != nums[i])&#123; a++ ; nums[a] = nums[i] ; count++; &#125; &#125; return count ; &#125; public static void main(String args[])&#123; int nums[] = &#123;1,1,2&#125; ; Solution s = new Solution(); System.out.println(s.removeDuplicates(nums)); &#125;&#125;]]></content>
      <categories>
        <category>algorithms</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式版本控制系统-Git]]></title>
    <url>%2Freversion-control%2F1625217789.html</url>
    <content type="text"><![CDATA[Git的安装以及基本操作 写在前面 GIt 教程：http://www.runoob.com/git/git-tutorial.html Git简介什么是Git?Git是一个开源的分布式版本控制系统。由大名鼎鼎的Linux之父Linus Torvalds开发，最初是为了帮助开发者管理Linux内核，但是发展至今，Git早已不仅仅是能够帮助开发人员管理Linux内核，使用Git能够帮助开发者高效地处理任何大小项目。 Git的安装Download地址：https://git-scm.com/downloads，这里我安装的windows版本的，安装过程基本就是一路next... 安装好后大概长这个样子： Git 基本操作查看版本信息1git --version 查看配置信息1git config --list 新建仓库12cd /your/pathgit init 克隆或检出仓库123cd /your/pathgit initgit clone /path/to/repository]]></content>
      <categories>
        <category>reversion_control</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown使用]]></title>
    <url>%2Fmarkdown%2F684580851.html</url>
    <content type="text"><![CDATA[写过博客的人应该都知道Markdown，作为一种轻量级的文本标记语言，Markdown可以让人们通过简单的标记，轻松地进行文本的排版！正如你在现在所看到的，Markdown使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接。Markdown在线编辑网站：马克飞象，Markdown编辑器推荐：Typora。 基础语法标题1234567891011121314用#或者&lt;hr&gt;标签表示标题# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题---------------------&lt;hr 1&gt; 这是一级标题&lt;hr 2&gt; 这是二级标题&lt;hr 3&gt; 这是三级标题&lt;hr 4&gt; 这是四级标题&lt;hr 5&gt; 这是五级标题&lt;hr 6&gt; 这是六级标题 由于会影响左侧目录所以效果这里就不展示出来了。 强调123456*这会是 斜体 的文字*_这会是 斜体 的文字_**这会是 斜体 的文字**__这会是 斜体 的文字__*组合**加粗**文字*~~删除线~~ 效果： 这是 斜体 的文字，这是 斜体 的文字，这是 粗体 的文字，这是 粗体 的文字，组合加粗文字，看见中间的删除线了吗 Tip: 如果想要对文字进行加粗和斜体，可以使用_和**进行组合达到效果，例如 加粗斜体 ，写法：_**加粗斜体**_ 列表无序列表12345678910无序列表可以使用*、+、- 号表示- 1级无序列表 * 2级无序列表 + 3级无序列表 + 3级无序列表 * 2级无序列表 * 2级无序列表 - 3级无序列表 + 3级无序列表 - 2级无序列表 1级无序列表 2级无序列表 3级无序列表 3级无序列表 2级无序列表 2级无序列表 3级无序列表 3级无序列表 2级无序列表 有序列表123451. 有序12. 有序23. 有序3 1. 有序嵌套1 2. 有序嵌套2 效果： 有序1 有序2 有序3 有序嵌套1 有序嵌套2 图片12![GitHub](/images/apple-touch-icon-next.png)格式: ![Alt Text](url) 效果： 引用123&gt; 引用1&gt; 引用2 想偷懒，引用3 效果： 引用1引用2 想偷懒，不写 &gt; 引用3 分割线1三个或以上的***或---或___ 效果： 使用***分割啊啊啊啊啊 使用---分割啊啊啊啊啊 使用___分割啊啊啊啊啊 行内代码这是行内代码：public static void mian(String args[]){} 代码块1你所看见的这就是代码块的格式,使用一对```将代码括起来就行了 效果： 12345public class HelloWorld &#123; public static void main(String args[]) &#123; System.out.println("Hello World !") ; &#125;&#125; 表格1234First Header | Second Header------------ | -------------Content from cell 1 | Content from cell 2Content in the first column | Content in the second column 效果： First Header Second Header Content from cell 1 Content from cell 2 Content in the first column Content in the second column a b c d 反斜杠Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： 123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 例如： 12**两个星号表示加粗** 在字符加上反斜杠后则表示普通字符 \**加上反斜杠表示**\***一个星号表示斜体* 在字符加上反斜杠后则表示普通字符 \*加上反斜杠表示**\* 效果： 两个星号表示加粗 **加上反斜杠表示普通字符** 一个星号表示斜体 *加上反斜杠表示普通字符*]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-报错汇总]]></title>
    <url>%2Fhexo%2F3147575311.html</url>
    <content type="text"><![CDATA[博客从搭建到优化，基本上一路绿灯，今天终于迎来了&quot;first err&quot;,对着代码愣是懵逼了半天没找出来到底哪里错了。 模板渲染错误 (Template render error)错误信息如下： 12345678910111213141516171819202122232425262728293031INFO Start processingFATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: Error: template not found: ../_custom/sidebar.swig at Object._prettifyError (E:\Node_JS_Hexo\node_modules\nunjucks\src\lib.js:35:11) at E:\Node_JS_Hexo\node_modules\nunjucks\src\environment.js:547:19 at eval (eval at _compile (E:\Node_JS_Hexo\node_modules\nunjucks\src\environment.js:617:18), &lt;anonymous&gt;:13:11) at createTemplate (E:\Node_JS_Hexo\node_modules\nunjucks\src\environment.js:279:11) at next (E:\Node_JS_Hexo\node_modules\nunjucks\src\lib.js:283:7) at handle (E:\Node_JS_Hexo\node_modules\nunjucks\src\environment.js:313:11) at E:\Node_JS_Hexo\node_modules\nunjucks\src\environment.js:323:9 at next (E:\Node_JS_Hexo\node_modules\nunjucks\src\lib.js:281:7) at Object.asyncIter (E:\Node_JS_Hexo\node_modules\nunjucks\src\lib.js:287:3) at Environment.getTemplate (E:\Node_JS_Hexo\node_modules\nunjucks\src\environment.js:305:9) at eval (eval at _compile (E:\Node_JS_Hexo\node_modules\nunjucks\src\environment.js:617:18), &lt;anonymous&gt;:12:5) at fn (E:\Node_JS_Hexo\node_modules\a-sync-waterfall\index.js:26:24) at E:\Node_JS_Hexo\node_modules\a-sync-waterfall\index.js:66:22 at executeSync (E:\Node_JS_Hexo\node_modules\a-sync-waterfall\index.js:8:15) at E:\Node_JS_Hexo\node_modules\a-sync-waterfall\index.js:65:11 at waterfall (E:\Node_JS_Hexo\node_modules\a-sync-waterfall\index.js:71:38) at Environment.waterfall (E:\Node_JS_Hexo\node_modules\nunjucks\src\environment.js:368:12) at Template.root [as rootRenderFunc] (eval at _compile (E:\Node_JS_Hexo\node_modules\nunjucks\src\environment.js:617:18), &lt;anonymous&gt;:27:5) at Template.render (E:\Node_JS_Hexo\node_modules\nunjucks\src\environment.js:540:10) at Environment.renderString (E:\Node_JS_Hexo\node_modules\nunjucks\src\environment.js:364:17) at Promise (E:\Node_JS_Hexo\node_modules\hexo\lib\extend\tag.js:66:9) at Promise._execute (E:\Node_JS_Hexo\node_modules\bluebird\js\release\debuggability.js:303:9) at Promise._resolveFromExecutor (E:\Node_JS_Hexo\node_modules\bluebird\js\release\promise.js:483:18) at new Promise (E:\Node_JS_Hexo\node_modules\bluebird\js\release\promise.js:79:10) at Tag.render (E:\Node_JS_Hexo\node_modules\hexo\lib\extend\tag.js:64:10) at Object.tagFilter [as onRenderEnd] (E:\Node_JS_Hexo\node_modules\hexo\lib\hexo\post.js:230:16) at Promise.then.then.result (E:\Node_JS_Hexo\node_modules\hexo\lib\hexo\render.js:65:19) at tryCatcher (E:\Node_JS_Hexo\node_modules\bluebird\js\release\util.js:16:23) 确定代码没有错误，网上找了很多资料，最后发现了异常的原因，是因为我在一篇文章中贴入的代码存在有特殊字符，解析时讲表达式中的内容按函数处理了，所以导致了异常。解决的办法就是将特殊的字符进行转义或者直接删掉要贴入到Markdown文件的代码。 关于转义字符可以参考w3school git：无法找到命令&emsp;&emsp;几天没更新博客，今天更新的时候突然冒出了个：hexo clean command not found,在尝试了其他的两个命令hexo g和hexo d的时候也显示无法找到命令，于是输入node -v和npm -v发现都没问题，百度了一下说是环境变量的问题，顿时想起几天前在自己的机子上装了Oracle数据库，由于电脑原来用的是中文用户名，安装Oracle的时候报了个C++错误，大概就是安装路径不能够有中文，所以就把账户改成了英文的，包括C盘下的user目录下的用户文件夹也改了，于是尝试将原来的环境变量上的中文用户名改了，但是发现并木有用，于是又在PATH上添加了一条新的路径：C:\Users\LQZ\AppData\Roaming\npm\node_modules\hexo\bin,问题就解决了，原来的PATH路径是：C:\Users\XXX\AppData\Roaming\npm,其中XXX就是当前电脑的用户名。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT+Github Pages]]></title>
    <url>%2Fhexo%2F3167973627.html</url>
    <content type="text"><![CDATA[&ensp; 写在前面经过几天时间的折腾，终于搭建好了第一个个人博客站点，整个站点基于HEXO+Github Pages搭建，使用了NexT主题。已完成部分优化，后续会继续更新！ 优化配置侧栏新建页面以新建文档页面为例，新建分类、标签等页面与之类似，具体的操作如下： 新建documents页面12cd your site pathhexo new page &quot;documents&quot; 1、在主题配置文件中搜索menu，新增: documents: /documents || file2、修改~/themes/next/languages目录下的zh_Hans.yml文件，同样搜索menu，新增 documents: 文档3、修改~/source/documents目录下的index.md文件，在文件头部添加type: &quot;documents&quot;和 comments: false PDF预览安装PDF插件，插件的地址: https://github.com/superalsrk/hexo-pdf/ 插件安装12345cd your site pathhexo install hexo-pdf --save语法:&#123;% pdf url地址 %&#125;例如:&#123;% pdf http://www.example.com/demo.pdf %&#125;其他用法，请参考github 摘要图片简单来说就是将文章中的某一张图片作为摘要图片显示在摘要文字的后面，并且不会重复显示。文章摘要(excerpt)指的是每篇文章在首页显示的那部分内容，当然前提是我们自己设置了摘要内容。那么到底怎么做？首先要确保关闭自动摘要，也就是主题配置文件(~/themes/next/_config.yml)中的配置（默认情况下是关闭的）： 1234excerpt_description: falseauto_excerpt: enable: false length: 150 然后修改~/themes/next/layout/_macro/下的post.swig文件: 12345678910111213141516171819202122232425262728&#123;% if is_index %&#125; &#123;% if post.description and theme.excerpt_description %&#125; &#123;&#123; post.description &#125;&#125; &lt;!--noindex--&gt; &lt;div class="post-button text-center"&gt; &lt;a class="btn" href="&#123;&#123; url_for(post.path) &#125;&#125;"&gt; &#123;&#123; __('post.read_more') &#125;&#125; &amp;raquo; &lt;/a&gt; &lt;/div&gt; &lt;!--/noindex--&gt; &#123;% elif post.excerpt %&#125; &#123;&#123; post.excerpt &#125;&#125; &lt;!--下面是添加的代码--&gt; &#123;% if post.image %&#125; &lt;div class="out-img-topic"&gt; &lt;img src=&#123;&#123; post.image &#125;&#125; class="img-topic" /&gt; &lt;/div&gt; &#123;% endif %&#125; &lt;!--上面是添加的代码--&gt; &lt;!--noindex--&gt; &lt;div class="post-button text-center"&gt; &lt;a class="btn" href="&#123;&#123; url_for(post.path) &#125;&#125;&#123;% if theme.scroll_to_more %&#125;#&#123;&#123; __('post.more') &#125;&#125;&#123;% endif %&#125;" rel="contents"&gt; &#123;&#123; __('post.read_more') &#125;&#125; &amp;raquo; &lt;/a&gt; &lt;/div&gt; &lt;!--/noindex--&gt; 如果需要自定义样式，可以在~/themes/next/source/css/_custom/custom.styl中的custom.styl添加下面的代码： 12345678910111213141516171819202122// 去掉图片边框.posts-expand .post-body .fancybox img &#123; border: none; padding: 0px; margin: auto;&#125;// 图片外部的容器方框 .out-img-topic &#123; display: block; max-height:424px; margin-bottom: 24px; overflow: hidden;&#125;// 图片img.img-topic &#123; display: block ; margin-left: .7em; margin-right: .7em; padding: 0; float: right; clear: right;&#125; 最后，如果某一篇文章需要添加摘要图片，那么在文章的 front-matter 中添加image: url即可,url就是图片所在的路径或者链接地址。 摘要样式: 默认情况下，文章的摘要样式不太好看，字体有点大，我想将其设置得小一点，并且是斜体的，使用谷歌浏览器调试了一下，效果还不错，但是由于摘要文字被渲染完之后是使用&lt;p&gt;标签括住的，本来想在自定义配置文件custom.yml中，重新定义文章内的&lt;p&gt;标签，但是，部署到本地服务器的时候，发现文章内所有的文字效果都变了(~emmmm…)，后来想了一下，既然自定义&lt;p&gt;标签不行，那干脆定义一个选择器.description，但是使用一对标签&lt;p class=&quot;description&quot;&gt;这里是摘要文字&lt;/p&gt;将摘要括起来，然后在文章中使用&lt;!--more--&gt;截取文章摘要，发现有效果了。 样式: 配置文件：-\themes\next\source\css\_custom\custom.yml1234567// 文章内摘要样式(主要是用来设置摘要样式).post-body .description &#123; margin: 0 0 0 0; text-align:center; font-style: italic; font-size: 14px;&#125; 首页文章篇数首先安装插件，在git中输入如下命令： 123npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-tag --save 安装完插件，在站点配置文件中添加如下代码： 12345678910index_generator: per_page: 5archive_generator: per_page: 10 yearly: true // 这里可不写 monthly: true // 这里可不写tag_generator: per_page: 10 其中per_page表示的是文章的篇数，index：首页、archive：归档、tag：标签 首页文章分割线做法很简单，在~/themes/next/source/css/_custom/目录下的custom.styl文件中添加下面的代码： 12345678910.posts-expand &#123; .post-eof &#123; display: block; margin: $post-eof-margin-top auto $post-eof-margin-bottom; width: 100%; height: 3px; background: $grey-light; text-align: center; &#125;&#125; 设置完成后重新构建(hexo g)和部署(hexo d)，刷新页面即可看到效果 打赏功能现如今，越来越多的平台支持打赏功能，知识付费的时代正在到来，而HEXO也集成了这个功能，如果要开启这个功能，只需要修改主题配置文件，添加微信或者支付宝收款二维码图片的地址即可，例如： 123reward_comment: 一段文字描述！wechatpay: /path/to/wechat-reward-image // 微信收款二维码图片地址alipay: /path/to/alipay-reward-image // 支付宝收款二维码图片地址 禁用打赏文字抖动具体的做法就是注释掉文字抖动函数，文件路径：~/themes/next/source/css/_common/components/post/post-reward.styl 1234567891011## 注释打赏文字抖动函数，将下面代码注释掉#wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;#alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; 页面宽度默认情况下，next主题两边留白比较多，如果是文章中主要是文字的话，可能影响不大，但是在写技术文章的时候，可能会贴入较多的代码进行讲解，这个时候阅读代码会变得不方便。对于Pisces Scheme，需要同时修改header的宽度、.main-inner 的宽度以及.content-wrap的宽度。例如，使用百分比（Pisces 的布局定义在source\css\_schemes\Picses\_layout.styl中）： 123header&#123; width: 80%; &#125;.container .main-inner &#123; width: 80%; &#125;.content-wrap &#123; width: calc(100% - 260px); &#125; 上一篇，下一篇顺序默认情况下，文章底部的文章切换按钮(&lt;和&gt;)，其切换效果是反过来的，也就是当我们点击xxx &gt;的时候实际上是跳转到上一篇文章而不是我们所想的下一篇文章，所以对其进行修改： 文件路径:-\themes\next\layout\_macro\post.swig123456789101112131415161718192021222324252627&#123;% if not is_index and (post.prev or post.next) %&#125; &lt;div class="post-nav"&gt; &lt;div class="post-nav-next post-nav-item"&gt;- &#123;% if post.next %&#125;+ &#123;% if post.prev %&#125;- &lt;a href="&#123;&#123; url_for(post.next.path) &#125;&#125;" rel="next" title="&#123;&#123; post.next.title &#125;&#125;"&gt;+ &lt;a href="&#123;&#123; url_for(post.prev.path) &#125;&#125;" rel="prev" title="&#123;&#123; post.prev.title &#125;&#125;"&gt;- &lt;i class="fa fa-chevron-left"&gt;&lt;/i&gt; &#123;&#123; post.next.title &#125;&#125;+ &lt;i class="fa fa-chevron-left"&gt;&lt;/i&gt; &#123;&#123; post.prev.title &#125;&#125; &lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;span class="post-nav-divider"&gt;&lt;/span&gt; &lt;div class="post-nav-prev post-nav-item"&gt;- &#123;% if post.prev %&#125;+ &#123;% if post.next %&#125;- &lt;a href="&#123;&#123; url_for(post.prev.path) &#125;&#125;" rel="prev" title="&#123;&#123; post.prev.title &#125;&#125;"&gt;+ &lt;a href="&#123;&#123; url_for(post.next.path) &#125;&#125;" rel="next" title="&#123;&#123; post.next.title &#125;&#125;"&gt;- &#123;&#123; post.prev.title &#125;&#125; &lt;i class="fa fa-chevron-right"&gt;&lt;/i&gt;+ &#123;&#123; post.next.title &#125;&#125; &lt;i class="fa fa-chevron-right"&gt;&lt;/i&gt; &lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;/div&gt; &#123;% endif %&#125; 标题栏信息调整关于标题栏底下的信息，包括阅读时长，字数统计，评论数等，如果要修改字段的显示文字，例如将阅读时长改为热度,可以修改~/themes/next/languages/下的zh-Hans.yml文件，把相应的字段改为自己想要显示的文字即可。NexT本身集成了字数统计功能，只需要修改主题配置文件即可： 123456post_wordcount: item_text: true wordcount: true // 字数统计功能 min2read: false // 阅读时长功能 totalcount: false separated_meta: true 评论数的设置需要用到LeanCloud,具体的配置网上也有很多教程，这里就不贴出来了，传送门：LeanCloud,这里主要讲一下如何调整字数统计换行显示的问题，如果没有做修改，字数统计会换行显示，那么如何让其显示在一行上？很简单，只需要修改post.swig文件，文件路径：~/themes/next/layout/_macro/post.swig，+号表示添加的内容，-号表示删除的内容。 1234567891011121314151617181920212223242526272829303132333435363738394041&#123;% if theme.post_wordcount.wordcount or theme.post_wordcount.min2read %&#125; &lt;!--下面为添加的一句代码--&gt; + &lt;span class="post-meta-divider"&gt;|&lt;/span&gt; - &lt;div class="post-wordcount"&gt; + &lt;span class="post-wordcount"&gt; &#123;% if theme.post_wordcount.wordcount %&#125; &#123;% if not theme.post_wordcount.separated_meta %&#125; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt; &#123;% endif %&#125; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-file-word-o"&gt;&lt;/i&gt; &lt;/span&gt; &#123;% if theme.post_wordcount.item_text %&#125; &lt;span class="post-meta-item-text"&gt;&#123;&#123; __('post.wordcount') &#125;&#125;&amp;#58;&lt;/span&gt; &#123;% endif %&#125; &lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125; 字 &lt;/span&gt; &#123;% endif %&#125; &#123;% if theme.post_wordcount.wordcount and theme.post_wordcount.min2read %&#125; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt; &#123;% endif %&#125; &#123;% if theme.post_wordcount.min2read %&#125; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-clock-o"&gt;&lt;/i&gt; &lt;/span&gt; &#123;% if theme.post_wordcount.item_text %&#125; &lt;span class="post-meta-item-text"&gt;&#123;&#123; __('post.min2read') &#125;&#125; &amp;asymp;&lt;/span&gt; &#123;% endif %&#125; &lt;span title="&#123;&#123; __('post.min2read') &#125;&#125;"&gt; &#123;&#123; min2read(post.content) &#125;&#125; &lt;/span&gt; &#123;% endif %&#125; &lt;!--下面的/span原来是/div--&gt; - &lt;/div&gt; + &lt;/span&gt; &#123;% endif %&#125; + &lt;div&gt;&lt;/div&gt; 文章置顶要控制文章置顶，可以通过设定一个top值来实现，具体的做法就是修改hero-generator-index插件中的generator.js文件的排序函数，文件所在路径：~/node_modules/hexo-generator-index/lib/generator.js 修改后的代码： 12345678910111213141516171819202122232425262728293031'use strict';var pagination = require('hexo-pagination');module.exports = function(locals) &#123; var config = this.config;- var posts = locals.posts.sort(config.index_generator.order_by); ## 注释掉这一句，添加下面的代码+ var posts = locals.posts;+ posts.data = posts.data.sort(function(a, b) &#123;+ if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义+ if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排+ else return b.top - a.top; // 否则按照top值降序排+ &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面+ return -1;+ &#125; else if(!a.top &amp;&amp; b.top) &#123;+ return 1;+ &#125;+ else return b.date - a.date; // 都没定义按照文章日期降序排+ &#125;); var paginationDir = config.pagination_dir || 'page';+ var path = config.index_generator.path || ''; ## 注意这里，网上有一些教程里面缺了这一句代码 return pagination(path, posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 修改完成后，如果需要将文章置顶，则在文章的front-matter中添加top字段，top值越大越靠前，例如： 12345678910111213---title: HEXO+NexT+Github Pagesdate: 2018-05-17 16:36:17tags: - HEXO - 搭建 - 配置与优化categories: - HEXOcopyright: trueimage: top: 50--- 透明度设置修改内容模块和菜单栏的透明度文件路径：~/themes/next/source/css/_schemes/Pisces/_layout.styl，将.header-inner和.content-wrap下的background: white以及.sidebar下的background: $body-bg-color改为background: rgba(255,255,255,0.6);其中0.6表示的是透明度，可以根据自己的需要设置(范围：0~1)。 站点概况模块透明度文件路径：~/themes/next/source/css/_schemes/Pisces/_sidebar.styl,将.sidebar-inner下的background: white改为background: rgba(255,255,255,0.6); 导航头背景图只需要将原来的黑色背景换成背景图即可，即： 12345// 设置左上角站点背景.site-meta &#123; background-image: url("/picture/background/Flowing_Ribbon.jpg"); background-size: cover;&#125; 博文压缩安装gulp插件，在命令行中使用如下命令安装： 12npm install -g gulpnpm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 如果安装过程中出现了类似下面的警告信息，意思是说有些插件已经弃用了，或者改名了，又或者有更新了，跳过即可，当然，你也可以根据提示选择安装或者更新这些插件 12345678910111213141516171819$ npm install gulp-minify-css gulp-uglify gulp-htmlclean gulp-htmlmin gulp --savenpm WARN deprecated gulp-minify-css@1.2.4: Please use gulp-clean-cssnpm WARN deprecated gulp-util@3.0.8: gulp-util is deprecated - replace it, following the guidelines at https://medium.com/gulpjs/gulp-util-ca3b1f9f9ac5npm WARN deprecated graceful-fs@3.0.11: please upgrade to graceful-fs 4 for compatibility with current and future versions of Node.jsnpm WARN deprecated minimatch@2.0.10: Please update to minimatch 3.0.2 or higher to avoid a RegExp DoS issuenpm WARN deprecated minimatch@0.2.14: Please update to minimatch 3.0.2 or higher to avoid a RegExp DoS issuenpm WARN deprecated graceful-fs@1.2.3: please upgrade to graceful-fs 4 for compatibility with current and future versions of Node.jsnpm WARN notice [SECURITY] minimatch has the following vulnerability: 1 high. Go here for more details: https://nodesecurity.io/advisories?search=minimatch&amp;version=0.2.14 - Run `npm i npm@latest -g` to upgrade your npm version, and then `npm audit` to get more info.npm WARN notice [SECURITY] minimatch has the following vulnerability: 1 high. Go here for more details: https://nodesecurity.io/advisories?search=minimatch&amp;version=2.0.10 - Run `npm i npm@latest -g` to upgrade your npm version, and then `npm audit` to get more info.npm WARN notice [SECURITY] lodash has the following vulnerability: 1 low. Go here for more details: https://nodesecurity.io/advisories?search=lodash&amp;version=1.0.2 - Run `npm i npm@latest -g` to upgrade your npm version, and then `npm audit` to get more info.npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)+ gulp-htmlmin@4.0.0+ gulp-htmlclean@2.7.22+ gulp-uglify@3.0.0+ gulp-minify-css@1.2.4+ gulp@3.9.1added 289 packages in 53.036s 安装完成后，可以在命令行或者shell中输入gulp -v测试一下是否有问题，如果提示没有此命令，那么可能是环境变量没有配置好，Windows系统需要在高级系统属性中配置一些环境变量，由于我用的是Linux，所以我需要在shell中建立软连接: 123sudo ln -s /opt/node-v8.11.4-linux-x64/bin/gulp /usr/local/bin/gulp/opt/node-v8.11.4-linux-x64/bin/gulp : 指的是gulp的安装位置/usr/local/bin/gulp ：本地用户存放脚本的位置 除了安装gulp相关的插件外，我们还需要安装另外几个插件，主要是为了解决ES6兼容性的问题: 12npm install gulp-babel babel-preset-es2015 --savenpm install babel-core --save 安装完成后在站点目录下新建一个.babelrc文件，注意是有一个点的，文件的内容如下: 123&#123;&quot;presets&quot;: [&quot;es2015&quot; ]&#125; 完了之后在站点跟目录下新建一个gulpfile.js文件，在文件中输入一下代码: 12345678910111213141516171819202122232425262728293031323334353637var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');var babel = require('gulp-babel');// 压缩 public 目录 cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public 目录 htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩 public/js 目录 jsgulp.task('minify-js', function() &#123; return gulp.src('./public/**/*.js') // ES5检查 .pipe(babel()) .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 执行 gulp 命令时执行的任务gulp.task('default', [ 'minify-html','minify-css','minify-js']); 保存退出后便可以执行hexo clean、hexo g、gulp、hexo s命令查看效果。 文章顶部加载条最新版的Next自带了加载条效果，只需要在主题配置文件中开启即可: 配置文件:-\themes\next\config.yml12345678910111213141516171819# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-minimal 点击爱心效果创建JS文件在~\themes\next\source\js\src目录下创建一个新的JS文件，名字自己起，例如我的是myclicklove.js，然后在JS文件中添加如下代码： 1234567891011121314151617181920212223242526272829303132!function(e,t,a)&#123; function n()&#123; c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r() &#125;function r()&#123; for(var e=0;e&lt;d.length;e++) d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)) :(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:" +d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+"," +d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999"); requestAnimationFrame(r) &#125;function o()&#123; var t="function"==typeof e.onclick&amp;&amp;e.onclick; e.onclick=function(e)&#123; t&amp;&amp;t(),i(e) &#125; &#125;function i(e)&#123; var a=t.createElement("div"); a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a) &#125;function c(e)&#123; var a=t.createElement("style");a.type="text/css"; try&#123;a.appendChild(t.createTextNode(e))&#125; catch(t)&#123;a.styleSheet.cssText=e&#125; t.getElementsByTagName("head")[0].appendChild(a) &#125;function s()&#123; return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")" &#125;var d=[];e.requestAnimationFrame=function()&#123; return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame|| function(e)&#123; setTimeout(e,1e3/60) &#125; &#125;(),n()&#125;(window,document); 修改_layout.swig文件修改~\themes\next\layout\_layout.swig文件，在文件末尾添加一下代码即可： 1&lt;script type="text/javascript" src="/js/src/这里是你的js文件名.js"&gt;&lt;/script&gt; 修改完成后重新渲染，部署即可看到效果。 标签云颜色注意这里只是修改了原来标签云的颜色，如果想要其他的标签云效果，可以尝试安装插件hexo-tag-cloud -/themes/next/layout/page.swig1&#123;&#123; tagcloud(&#123;min_font: 13, max_font: 30, amount: 1000, color: true, start_color: &apos;#ff4b1f&apos;, end_color: &apos;#1fddff&apos;&#125;) &#125;&#125; 关于参数，可以参考hexo官方文档 添加emoji表情安装插件：hexo-filter-github-emojis 1$ npm install hexo-filter-github-emojis --save 在站点配置文件中进行配置： 1234567githubEmojis: enable: true- className: github-emoji+ idName: github-emoji unicode: false styles: localEmojis: 插件提供了两种渲染方式： 方式112345&lt;span class="' + options.className + '" ' + styles + ' title="' + emojiName + '" data-src="' + emojis[emojiName].src + '"&gt;' + codepoints + '&lt;/span&gt; 方式21234&lt;img class="' + options.className + '" ' + styles + ' title="' + emojiName + '" alt="' + emojiName + '" src="' + emojis[emojiName].src + '" height="20" width="20" /&gt; 其中方式一是使用unicode插入emoji表情时的渲染方式，默认不开启；方式2是默认的渲染方式，即最终的表情会以图片的形式嵌入文章中，但是这样会有一个问题就是，hexo的图片弹出层插件fancybox会对emoji表情产生影响，因此，需要对插件做一些调整，首先是修改js，替换所有className为idName，实际上只有3个className，不用担心替换错，之后删除title属性。 路径: -\node_modules\hexo-filter-github-emojis\index.js12345678910111213141516171819var codepoints = emojis[emojiName].codepoints if (options.unicode &amp;&amp; codepoints) &#123; codepoints = codepoints.map(function (code) &#123; return '&amp;#x' + code + ';' &#125;).join('') return '&lt;span class="' + options.className + '" ' + styles +- ' title="' + emojiName +- '" data-src="' + emojis[emojiName].src ++ ' data-src="' + emojis[emojiName].src + '"&gt;' + codepoints + '&lt;/span&gt;' &#125; else &#123; return '&lt;img class="' + options.className + '" ' + styles +- ' title="' + emojiName + '" alt="' + emojiName + '" src="' ++ ' alt="' + emojiName + '" src="' + emojis[emojiName].src + '" height="20" width="20" /&gt;' &#125; 注意上面的data-src=以及alt=前面是没有双引号的，只有单引号。上面的修改主要是去掉了表情图片下面的title，除此之外，还需要修改表情的样式，受fancybox的影响，嵌入的表情会换行居中显示，这显然不是我们想要的效果，我们要修改表情的样式，让其显示在文字的后面： 路径：-\themes\next\source\css\_custom\custom.styl12345678910// 自定义emoji样式.posts-expand .post-body img.github-emoji &#123; margin: 0px; padding: 0px; display: inline !important; vertical-align: text-bottom; border: none; cursor: text; box-shadow: none;&#125; 经过上面的修改，表情包已经可以在文字的后面显示了，但这还不够，因为当我们点击表情包的时候，依旧会受到fancybox的影响，像图片一样弹出，我希望的效果是即使我点击表情包，它也不会像其他图片一样弹出来，所以，我们要进一步修改，找到~/themes/next/source/js/src/utils.js，添加一行代码: 1234567891011121314151617181920212223242526wrapImageWithFancyBox: function () &#123; $('.content img') .not('[hidden]') .not('.group-picture img, .post-gallery img') .each(function () &#123; var $image = $(this); // 禁用emoji表情包的fancybox效果+ if ($(this).hasClass('github-emoji')) return; var imageTitle = $image.attr('title'); var $imageWrapLink = $image.parent('a'); if ($imageWrapLink.size() &lt; 1) &#123; var imageLink = ($image.attr('data-original')) ? this.getAttribute('data-original') : this.getAttribute('src'); $imageWrapLink = $image.wrap('&lt;a href="' + imageLink + '"&gt;&lt;/a&gt;').parent('a'); &#125; $imageWrapLink.addClass('fancybox fancybox.image'); $imageWrapLink.attr('rel', 'group'); if (imageTitle) &#123; $imageWrapLink.append('&lt;p class="image-caption"&gt;' + imageTitle + '&lt;/p&gt;'); //make sure img title tag will show correctly in fancybox $imageWrapLink.attr('title', imageTitle); &#125; &#125;); 注:代码的意思就是所有带有github-emoji类选择器的img标签都禁用fancybox效果 到这里，如果文章中的超链接设置了鼠标移进去显示下划线的话，那么这里的表情图片也会有这种效果，所以还要去掉表情包的下划线，但是有个问题就是：表情包的下划线是没了，但是站点内其他链接的样式都被影响了，没办法，为了emoji只能修改了 路径：-\themes\next\source\css\_custom\custom.styl12345678910111213141516171819202122232425262728293031323334353637383940// 导航头超链接样式.header-inner a &#123; color: rgb(80, 115, 184); border-bottom: none;&#125;.header-inner a:hover &#123; color: rgb(161, 102, 171); border-bottom: 1px solid rgb(161, 102, 171);&#125;// 导航头站点元数据超链接样式.site-meta a &#123; color: rgb(233, 233, 233); border-bottom: none;&#125;.site-meta a:hover &#123; color: rgb(233, 233, 233); border-bottom: none;&#125;// 首页超链接样式.content-wrap a &#123; color: rgb(80, 115, 184); border-bottom: none;&#125;.content-wrap a:hover &#123; color: rgb(161, 102, 171); border-bottom: none;&#125;// 文章内超链接样式.post-body a &#123; color: rgb(80, 115, 184); border-bottom: none;&#125;.post-body a:hover &#123; color: rgb(161, 102, 171); border-bottom: none;&#125;// 首页标题超链接样式.post-title a:hover &#123; color: rgb(85, 85, 85);&#125; 剩下的最重要的一点就是表情包网站，要使用表情包可以到这个网站拷贝：https://www.webfx.com，使用的方法也很简单： 语法&#123;% github_emoji 表情包名字 %&#125;# 拷贝到的表情包去掉左右的冒号即为表情包的名字# For example:&#123;% github_emoji sparkles %&#125; 更多的使用的方法可以参考GitHub大佬的文章：https://reuixiy.github.io另：附上另一个表情包网站：https://www.emojicopy.com 文章结束标志在~/themes/next/layout/_macro/目录下新建一个end-tag.swig文件，添加如下代码: 1234567&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt; ----- Thank you &lt;i class="fa fa-paw"&gt;&lt;/i&gt; for reading ----- &lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 其中----- Thank you &lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt; for reading -----这一部分可以改成你自己想要显示的内容，之后修改同级目录下的post.swig文件，在END POST BODY后面，添加如下代码: 123&#123;% if not is_index %&#125; &#123;% include 'end-tag.swig' %&#125;&#123;% endif %&#125; 注意这里代码添加的位置根据自己的需要来添加，我这里是添加到: 1234567891011&#123;% if post.tags and post.tags.length and not is_index %&#125; &lt;div class="post-tags"&gt; &#123;% for tag in post.tags %&#125; &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" &lt;i class="fa fa-tag"&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125; &lt;/div&gt;&#123;% endif %&#125;+ &#123;% if not is_index %&#125;+ &#123;% include 'end-tag.swig' %&#125;+ &#123;% endif %&#125; 个性化配置字体设置编辑主题下的source\css\_variables\custom.styl文件,添加下面的代码(可根据需要修改)： 1234567891011121314// 标题，修改成你期望的字体族$font-family-headings = Georgia, sans// 修改成你期望的字体族$font-family-base = "Microsoft YaHei", Verdana, sans-serif// 代码字体$code-font-family = "Input Mono", "PT Mono", Consolas, Monaco, Menlo, monospace// 正文字体的大小$font-size-base = 16px// 代码字体的大小$code-font-size = 13px 背景色块有时候我们希望能够对某些文字进行背景色填充，用Markdown语法好像不好实现，所以干脆自己自定义颜色填充，需要用的时候直接调用即可，具体的做法：编辑themes/next/source/css/_custom下的custom.styl文件,添加属性样式： 文件位置：themes/next/source/css/_custom/custom.styl1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 颜色块-黄span#inline-yellow &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #f0ad4e;&#125;// 颜色块-绿span#inline-green &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #5cb85c;&#125;// 颜色块-蓝span#inline-blue &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #2780e3;&#125;// 颜色块-紫span#inline-purple &#123; display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #9954bb;&#125; 在需要进行背景色填充的文字上加上相应的标签，例如： 1234&lt;span id="inline-blue"&gt; 这是蓝色填充 &lt;/span&gt;&lt;span id="inline-purple"&gt; 这是紫色填充&lt;/span&gt;&lt;span id="inline-yellow"&gt; 这是黄色填充 &lt;/span&gt;&lt;span id="inline-green"&gt; 这是绿色填充 &lt;/span&gt; 这是蓝色填充这是紫色填充这是黄色填充这是绿色填充 播放视频使用插件 要播放视需要用到一个插件dplayer,将插件安装到站点文件夹的根目录下面，安装插件的命令如下： 使用 npm 安装: 1npm install dplayer --save 或者 npm install hexo-tag-dplayer --save 使用 yarn 安装： 1yarn add dplayer 安装完成后，将下面的代码添加到Markdown文件中，并相应的地址即可 1&#123;% dplayer url&quot;=https://******.mp4&quot; &quot;http://******.jpg&quot; &quot;api=https://api.prprpr.me/dplayer/&quot; &quot;id=&quot; &quot;loop=false&quot; %&#125; 直接在Markdown文件中插入外链接 1、使用iframe标签：在Markdown文件中插入如下代码链接，链接可在视频网站获取 1&lt;iframe src="//player.bilibili.com/player.html?aid=22642915&amp;cid=37570456&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"&gt; &lt;/iframe&gt; 1&lt;video src="//player.bilibili.com/player.html?aid=22642915&amp;cid=37570456&amp;page=1" autoplay="false" controls="controls" width="100%" height="100%"&gt; &lt;/video&gt; 直接使用iframe标签插入视频，需要手工调整窗体大小，而且整体效果并不好。如果将宽度和高度设置为width=&quot;100%&quot; height=&quot;100%&quot;,可以解决手机端显示的问题，但是在电脑端显示变得很小。 2、插入bilibili HTML5播放器 1&lt;iframe src="http://www.bilibili.com/html/html5player.html?aid=22642915&amp;cid=37570456" scrolling="no" border="0" width="740" height="440" frameborder="0" framespacing="0" allowfullscreen="true"&gt;&lt;/iframe&gt; 插入音乐以网易云为例，打开网页版的网易云音乐，随便播放一首音乐，点击左侧专辑封面下面有一个生成外链播放器，复制下方的HTML代码并放到Markdown文件中即可。其中有两个个比较常用的参数可根据自己的需要进行设置：height设为0可隐藏播放器；auto设为0则表示手动播放，设为1则表示自动播放。 1&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&amp;id=28718818&amp;auto=1&amp;height=66"&gt;&lt;/iframe&gt; 或者直接用HTMl标签，写法如下： 1&lt;audio src="https://Xxx.mp3" style="max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;" controls="controls" loop="loop" preload="meta"&gt;Your browser does not support the audio tag.&lt;/audio&gt; 背景图和背景色设置背景图片比较简单，修改~/themes/next/source/css/_custom/路径下的custom.styl文件，添加下面的代码即可： 123456body &#123; background-image: url(背景图片的路径/Xxx.jpg); background-attachment: fixed; background-repeat: repeat; background-size: contain;&#125; 如果不想设置背景图片，但又想修改默认的主题背景色，注意是背景色，不是背景图片，那么这个时候就可通过修改~\themes\next\source\css\_variables\Pisces.styl文件来修改默认的背景色，修改的参数如下： 123// Settings for some of the most global styles.// --------------------------------------------------$body-bg-color = #DCDCDC // 注意这里根据自己的需要进行设置，改为自己想要的颜色代码即可 ~\themes\next\source\css_variables 这个目录下保存了各个主题以及通用的基本配置参数 写作样式很多时候我们会发现，使用Markdown写作会有一定的局限性，毕竟有时候我们会想在文章中加入一些有意思的样式来提高文章的阅读效果。 主题自带样式：note标签这是Next自带的主题，在主题配置文件 (config.yml) 中有相关的设置。有关note的style可以在此处预览点我 主题配置文件:-\themes\next\config.yml123456789101112131415# Note tag (bs-callout).note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. # 风格 style: simple # 是否使用图标 icons: true border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0 用法以及效果: 1&lt;div class="note default"&gt;&lt;p&gt;default&lt;/p&gt;&lt;/div&gt; default 1&lt;div class="note primary"&gt;&lt;p&gt;primary&lt;/p&gt;&lt;/div&gt; primary 1&lt;div class="note success"&gt;&lt;p&gt;success&lt;/p&gt;&lt;/div&gt; success 1&lt;div class="note info"&gt;&lt;p&gt;info&lt;/p&gt;&lt;/div&gt; info 1&lt;div class="note warning"&gt;&lt;p&gt;warning&lt;/p&gt;&lt;/div&gt; warning 1&lt;div class="note danger"&gt;&lt;p&gt;danger&lt;/p&gt;&lt;/div&gt; danger 1&lt;div class="note danger no-icon"&gt;&lt;p&gt;danger no-icon&lt;/p&gt;&lt;/div&gt; danger no-icon 如果想修改默认的样式可以修改~\themes\next\source\css\_variables\base.styl文件，默认的样式如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// Note colors// --------------------------------------------------// Read note light_bg_offset from NexT config and set in "lbg%" to use it as string variable.hexo-config('note.light_bg_offset') is a 'unit' ? (lbg = unit(hexo-config('note.light_bg_offset'),"%")) : (lbg = 0)// Default$note-default-border = #777$note-default-bg = lighten(spin($note-default-border, 0), 94% + lbg)$note-default-text = $note-default-border$note-default-icon = "\f0a9"$note-modern-default-border = #e1e1e1$note-modern-default-bg = lighten(spin($note-modern-default-border, 10), 60% + (lbg * 4))$note-modern-default-text = $grey-dim$note-modern-default-hover = darken(spin($note-modern-default-text, -10), 32%)// Primary$note-primary-border = #6f42c1$note-primary-bg = lighten(spin($note-primary-border, 10), 92% + lbg)$note-primary-text = $note-primary-border$note-primary-icon = "\f055"$note-modern-primary-border = #e1c2ff$note-modern-primary-bg = lighten(spin($note-modern-primary-border, 10), 40% + (lbg * 4))$note-modern-primary-text = #6f42c1$note-modern-primary-hover = darken(spin($note-modern-primary-text, -10), 22%)// Info$note-info-border = #428bca$note-info-bg = lighten(spin($note-info-border, -10), 91% + lbg)$note-info-text = $note-info-border$note-info-icon = "\f05a"$note-modern-info-border = #b3e5ef$note-modern-info-bg = lighten(spin($note-modern-info-border, 10), 50% + (lbg * 4))$note-modern-info-text = #31708f$note-modern-info-hover = darken(spin($note-modern-info-text, -10), 32%)// Success$note-success-border = #5cb85c$note-success-bg = lighten(spin($note-success-border, 10), 90% + lbg)$note-success-text = $note-success-border$note-success-icon = "\f058"$note-modern-success-border = #d0e6be$note-modern-success-bg = lighten(spin($note-modern-success-border, 10), 40% + (lbg * 4))$note-modern-success-text = #3c763d$note-modern-success-hover = darken(spin($note-modern-success-text, -10), 27%)// Warning$note-warning-border = #f0ad4e$note-warning-bg = lighten(spin($note-warning-border, 10), 88% + lbg)$note-warning-text = $note-warning-border$note-warning-icon = "\f06a"$note-modern-warning-border = #fae4cd$note-modern-warning-bg = lighten(spin($note-modern-warning-border, 10), 43% + (lbg * 4))$note-modern-warning-text = #8a6d3b$note-modern-warning-hover = darken(spin($note-modern-warning-text, -10), 18%)// Danger$note-danger-border = #d9534f$note-danger-bg = lighten(spin($note-danger-border, -10), 92% + lbg)$note-danger-text = $note-danger-border$note-danger-icon = "\f056"$note-modern-danger-border = #ebcdd2$note-modern-danger-bg = lighten(spin($note-modern-danger-border, 10), 35% + (lbg * 4))$note-modern-danger-text = #a94442$note-modern-danger-hover = darken(spin($note-modern-danger-text, -10), 22%) 主题自带样式：label标签label标签与note标签类似，也是自带的，默认情况下是启用的。 文件路径:-\themes\next\config.yml12# Label tag.label: true 用法以及效果: @前面是label名称，后面是要显示的文本内容 1&#123;% label default@default %&#125; default 1&#123;% label primary@primary %&#125; primary 1&#123;% label success@success %&#125; success 1&#123;% label info@info %&#125; info 1&#123;% label warning@warning %&#125; warning 1&#123;% label danger@danger %&#125; danger 默认的label样式12345678// Label colors// --------------------------------------------------$label-default = lighten(spin($note-default-border, 0), 89% + lbg)$label-primary = lighten(spin($note-primary-border, 10), 87% + lbg)$label-info = lighten(spin($note-info-border, -10), 86% + lbg)$label-success = lighten(spin($note-success-border, 10), 85% + lbg)$label-warning = lighten(spin($note-warning-border, 10), 83% + lbg)$label-danger = lighten(spin($note-danger-border, -10), 87% + lbg) 主题自带样式：tabs标签tabs标签的效果有点类似于可切换的表格： 用法：1234567891011&#123;% tabs 选项卡, 2 %&#125;&lt;!-- tab --&gt;**这是选项卡 1**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**这是选项卡 2**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**这是选项卡 3**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 效果: 选项卡 1选项卡 2选项卡 3这是选项卡 1 上面的选项卡点击可以切换 这是选项卡 2 这是选项卡 3 主题自带样式：按钮用法:1234&#123;% btn URL, Text, icon [class], Title %&#125;# URL: 按钮的链接地址，例如：https://www.github.com# Text: 按钮上显示的文本信息，例如：github# icon[class]: 按钮上显示图标 效果: 百度一下 更多按钮的用法可以查看这位大佬的文章：https://almostover.ru/2016-01/hexo-theme-next-test/#Button-tag-test 主题自带样式：代码块高亮java代码高亮百度一下，你就知道12345public class HelloWorld &#123; public static void main(String[] args)&#123; System.out.prinltn("Hello World !") ; &#125;&#125; 完整的用法: 在第一个```后面添加相应的信息即可：[language] [title] [url] [link-text] [language] 是代码语言的名称，用来设置代码块颜色高亮，非必须； [title] 是顶部左边的说明，非必须； [url] 是顶部右边的超链接地址，非必须； [link text] 如它的字面意思，超链接的名称，非必须。 添加居中模块1&lt;blockquote class="blockquote-center"&gt;生活不止眼前的苟且，还有诗和远方！&lt;/blockquote&gt; 效果: 生活不止眼前的苟且，还有诗和远方！ 插入图片与PDF文档关于Hexo的其他配置可以参考：Hexo官方文档 插入图片: 使用Markdown插入图片的语法格式如下: ![Alt text](path) [Alt text]：图片的描述文字[path]：图片所在的路径 除了使用Markdown之外，也可以使用HTML的&lt;img&gt;标签: 1&lt;img src="image_path" tltle="titleName" alt="altName" width="width"&gt; [image path]：图片的路径[Alt text]：显示的文本[width]：图片的宽度 效果图片： 插入PDF文档: 将相应的PDF文档放在与博客标题同名的文件夹内，然后再按照如下方式进行插入: [PDF File](FileName.pdf) 这是插入的PDF文档 添加注脚1npm install hexo-reference --save 用法： 使用指南1、加注：this is a basic footnote[^text] ##text是显示的文本，例如1.2、在文章的任意位置添加注脚的内容，如：[^text]:这里写注脚要显示的内容. 效果： 这是一个注脚[1]，在解析md文章的时候，会在文章的最后生成一个注脚。 自定义Note标签1234567891011121314151617181920212223242526.alert &#123; padding: 15px; margin-bottom: 20px; border: 1px solid transparent; border-radius: 4px;&#125;.alert-warning &#123; color: #c09853; background-color: #fcf8e3; border-color: #faebcc;&#125;.alert-success &#123; color: #468847; background-color: #dff0d8; border-color: #d6e9c6;&#125;.alert-info &#123; color: #3a87ad; background-color: #e2eaee; border-color: #c5d5dd;&#125;.alert-danger &#123; color: #b94a48; background-color: #f2dede; border-color: #ebccd1;&#125; 1&lt;div class="alert alert-success"&gt;&lt;i class="fa fa-lightbulb-o"&gt;&lt;/i&gt; BUG虐我千百遍，我待BUG如初恋 &lt;/div&gt; BUG虐我千百遍，我待BUG如初恋 1&lt;div class="alert alert-info"&gt;&lt;i class="fa fa-info"&gt;&lt;/i&gt; BUG虐我千百遍，我待BUG如初恋 &lt;/div&gt; BUG虐我千百遍，我待BUG如初恋 1&lt;div class="alert alert-warning"&gt;&lt;i class="fa fa-bell"&gt;&lt;/i&gt; BUG虐我千百遍，我待BUG如初恋 &lt;/div&gt; BUG虐我千百遍，我待BUG如初恋 1&lt;div class="alert alert-danger"&gt;&lt;i class="fa fa-bug"&gt;&lt;/i&gt; BUG虐我千百遍，我待BUG如初恋 &lt;/div&gt; BUG虐我千百遍，我待BUG如初恋 TOC数字块样式12345678910.section-number-2 &#123; display: inline-block; border-radius: 80% 100% 90% 20%; word-wrap: break-word!important; background-color: #8c8c8c; color: #fff; min-width: .8em; padding: .3em .4em; margin: 2px 5px 2px 0;&#125; 效果： 1.&lt;span class=&quot;section-number-2&quot;&gt;&lt;/span&gt; 常用命令1234567891011121314// 清除缓存hexo clean// 渲染成htmlhexo g// 本地部署hexo s || hexo s -p 端口号// 远程部署hexo d// 安装插件npm install &quot;插件名称&quot; --save// 卸载插件npm uninstall &quot;插件名称&quot; --save// 查看依赖包信息cat package.json 下面是我的依赖包信息，主要是一些已安装的插件信息： 依赖包1234567891011121314151617181920212223242526272829303132&#123; "name": "hexo-site", "version": "0.0.0", "private": true, "hexo": &#123; "version": "3.7.1" &#125;, "dependencies": &#123; "gulp": "^3.9.1", "gulp-htmlclean": "^2.7.22", "gulp-htmlmin": "^4.0.0", "gulp-minify-css": "^1.2.4", "gulp-uglify": "^3.0.0", "hexo": "^3.2.0", "hexo-deployer-git": "^0.3.1", "hexo-generator-archive": "^0.1.5", "hexo-generator-baidu-sitemap": "^0.1.2", "hexo-generator-category": "^0.1.3", "hexo-generator-index": "^0.2.1", "hexo-generator-searchdb": "^1.0.8", "hexo-generator-sitemap": "^1.2.0", "hexo-generator-tag": "^0.2.0", "hexo-reference": "^1.0.3", "hexo-renderer-ejs": "^0.3.0", "hexo-renderer-marked": "^0.3.0", "hexo-renderer-stylus": "^0.3.1", "hexo-server": "^0.2.0", "hexo-tag-aplayer": "^3.0.4", "hexo-tag-dplayer": "^0.3.3", "hexo-wordcount": "^3.0.2" &#125;&#125; Seo优化中文链接问题 插件github地址 默认情况下，hexo使用文章创建的时间和文章的标题作为访问URL的一部分，但这样有一个问题就是，如果你的文章标题使用了中文，那么，访问的URL地址中就会出现中文，所以如果你是处女座或者有强迫症，这种问题是绝对不能忍受的，当然，从另一方面来看，这也不利于搜索优化，所以我们要对其进行改进，这里采用的方法是使用hexo-abbrlink插件，用法相当简单，先安装插件: 1npm install hexo-abbrlink --save 修改站点配置文件，搜索permalink，修改为: 1234permalink: :abbrlink.html # 生成唯一链接abbrlink: alg: crc16 # 算法:crc16(默认) and crc32 rep: dec # 进制:dec(默认) and hex 自动推送博客搭建完之后，如果我们希望搜索引擎能够快速地收录我们的博客，那么我们就可以利用百度或者Google的站长工具主动推送自己的博客，因为我自己并没有提交到Google，所以，这里以百度为例，提交到百度可以从两个方面来进行，第一个是登录百度站长平台主动提交站点信息，这一部分基本都是图形化操作，这里就不说了；另一个就是使用Next自带的SEO优化功能，这一部分的设置可以在主题配置文件中开启: 1baidu_push: true 接下在~/themes/next/source/js/src下新建一个js文件:sitemap.js，内容为: 123456789101112// SEO自动推送(function()&#123; var bp = document.createElement(&apos;script&apos;); var curProtocol = window.location.protocol.split(&apos;:&apos;)[0]; if (curProtocol === &apos;https&apos;) &#123; bp.src = &apos;https://zz.bdstatic.com/linksubmit/push.js&apos;; &#125; else &#123; bp.src = &apos;http://push.zhanzhang.baidu.com/push.js&apos;; &#125; var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s);&#125;)(); 完了之后，需要在页面中引入sitemap.js，我这里是在~/themes/next/layout/_custom目录下的header.swig文件中引入: 1&lt;script src=&quot;/js/src/sitemap.js&quot;&gt;&lt;/script&gt; 站点地图要使用站点地图，需要安装插件: 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 接下来修改站点配置文件 12345# 网站地图sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 站点地图在执行hexo g命令完整渲染后生成的sitemap.xml和baidusitemap.xml会放置到public文件夹下 结束语 由于非JS出身，在博客的搭建与优化的过程中，碰到了不少问题，也走了不少弯路，但是由衷感谢各位大神的文章，让自己学到了不少东西，下面是本人参考过的部分文章以及文档。 配置参考： https://qianling.pw https://www.ofind.cn/ https://reuixiy.github.io https://www.vincentqin.tech http://theme-next.iissnan.com/ https://hexo.io/zh-cn/docs/writing.html https://zhuanlan.zhihu.com/p/308364361.这是一个用于测试的注脚 ↩]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>搭建</tag>
        <tag>配置与优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhexo%2F1243066710.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hello world</tag>
      </tags>
  </entry>
</search>
